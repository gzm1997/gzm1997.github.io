<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>gzm&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="gzm&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="gzm&#39;s blogs">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="gzm&#39;s blogs">
  
    <link rel="alternate" href="/atom.xml" title="gzm&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">gzm&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-cayley原理2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/20/cayley原理2/" class="article-date">
  <time datetime="2018-08-20T09:25:00.000Z" itemprop="datePublished">2018-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/20/cayley原理2/">cayley原理2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="cayley查询过程"><a href="#cayley查询过程" class="headerlink" title="cayley查询过程"></a>cayley查询过程</h2><p>cayley的查询过程相当复杂 下面是我个人的学习结果 仅仅是个人看法 无法保证绝对正确<br><img src="http://static.zybuluo.com/gzm1997/no1a9uh8euf17s9v1hm9k9ou/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180820172126.png" alt="微信图片_20180820172126.png-16.9kB"></p>
<hr>
<h2 id="构造态射数组"><a href="#构造态射数组" class="headerlink" title="构造态射数组"></a>构造态射数组</h2><p>对于我们用来查询的结构path<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Path <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack       []morphism</span><br><span class="line">	qs          graph.QuadStore <span class="comment">// Optionally. A nil qs is equivalent to a morphism.</span></span><br><span class="line">	baseContext pathContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>morphism态射</strong>在范畴论中就是一个函数变换的抽象过程 cayley中的态射我们可以理解是我们每一个out int has等等指向下一个节点迭代的函数封装 我们每一个指向下一个的迭代(in out等)都转换为一个morphism态射 然后存在path中的stack<strong>态射数组</strong></p>
<blockquote>
<p>这个stack存储着表示我们查询的每一个划分(out in has等等)的态射</p>
</blockquote>
<p>每一个态射在cayley中的定义 </p>
<ul>
<li>其中Reversal返回的态射是一个反向的态射(比如out的反向态射就是in) 这就是cayley实现无向图的原因 每个态射都包含一个它的反向态射</li>
<li>Apply为执行这个态射的具体函数 这个函数返回值中得到的shape中就表示了执行态射后得到的节点</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> morphism <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsTag    <span class="keyword">bool</span></span><br><span class="line">	Reversal <span class="function"><span class="keyword">func</span><span class="params">(*pathContext)</span> <span class="params">(morphism, *pathContext)</span></span></span><br><span class="line"><span class="function">	<span class="title">Apply</span>    <span class="title">applyMorphism</span></span></span><br><span class="line"><span class="function">	<span class="title">tags</span>     []<span class="title">string</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>举一个简答的例子 下面的查询path是从A这个节点出发 经过节点12 查询可以获得什么节点</p>
<pre><code>p := cayley.StartPath(store, quad.String(&quot;A&quot;)).Out(quad.Int(12))
</code></pre><p>上面这条查询语句在声明了一个path结构体的同时 也构造出我们上面所说的<strong>态射数组</strong><br>下面的绿色大框即为我们的态射数组stack 两个蓝色框即为我们数组中的两个态射 都是morphism结构体 但是我们可以看红色框框 他们的apply这个函数是不一样的 一个是isMorphism 一个outMorphism</p>
<p><img src="http://static.zybuluo.com/gzm1997/76y9vn6l45cx30d3w747rpy2/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180820155549.png" alt="微信图片_20180820155549.png-45.6kB"></p>
<p>我们可以很容易理解为什么有outMorphism态射 但是不能理解为什么有isMorphism这个态射 其实这是初始化的态射</p>
<hr>
<h2 id="构造shape"><a href="#构造shape" class="headerlink" title="构造shape"></a>构造shape</h2><p>shape顾名思义就是我们查询路径的一种表现形式 表示了我们使用path查询始末的一条抽象路径 如上面的查询抽象的一个shape就是</p>
<pre><code>A -&gt; 12 -&gt;
</code></pre><p>shape在cayley中只是一个接口 但凡实现了这个接口中的方法的结构体都是shape 具体的形式非常多样和复杂 我们这里不做详细研究 shape接口定义如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shape represent a query tree shape.</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// BuildIterator constructs an iterator tree from a given shapes and binds it to QuadStore.</span></span><br><span class="line">	BuildIterator(qs graph.QuadStore) graph.Iterator</span><br><span class="line">	<span class="comment">// Optimize runs an optimization pass over a query shape.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It returns a bool that indicates if shape was replaced and should always return a copy of shape in this case.</span></span><br><span class="line">	<span class="comment">// In case no optimizations were made, it returns the same unmodified shape.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If Optimizer is specified, it will be used instead of default optimizations.</span></span><br><span class="line">	Optimize(r Optimizer) (Shape, <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个具体的shape的例子 可见shape的具体类型和机构是很多样的 没必要具体研究<br><img src="http://static.zybuluo.com/gzm1997/bamzi6zpilvq6sha5khhxro8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180820162647.png" alt="微信图片_20180820162647.png-31.5kB"></p>
<p>可以看到下面 随着态射一个一个被执行 我们的到的构造出来的shape也是变化的 每一次态射之后的到的shape都作为参数传入下一个被执行的态射函数 shape不断积累 最终形成我们需要的查询路径<br><img src="http://static.zybuluo.com/gzm1997/2x1c3zt37b32j3u8st294mu5/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180820162145.png" alt="微信图片_20180820162145.png-17.3kB"></p>
<p>构造shape部分还包含了大量的shape优化 这部分复杂而内容很多 这里不展开</p>
<hr>
<h2 id="构造迭代器和迭代链链"><a href="#构造迭代器和迭代链链" class="headerlink" title="构造迭代器和迭代链链"></a>构造迭代器和迭代链链</h2><p><strong>Iterator迭代器</strong>这个概念我们可以理解只负责某一部分计算工作的组件 cayley的查询设计是由若干个迭代器<strong>嵌套</strong>或者<strong>依次排列</strong>组合成的 呈现一个<strong>分布式结构</strong> 组合成的最终迭代器叫做<strong>IterateChain迭代器链</strong></p>
<p>cayley中对于迭代器的声明也是一个接口 在cayley中但凡实现了这个接口中所有方法的结构体我们都统称为迭代器Iterator</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">	Tagger() *Tagger</span><br><span class="line">	TagResults(<span class="keyword">map</span>[<span class="keyword">string</span>]Value)</span><br><span class="line">	Result() Value</span><br><span class="line">	Next(ctx context.Context) <span class="keyword">bool</span></span><br><span class="line">	NextPath(ctx context.Context) <span class="keyword">bool</span></span><br><span class="line">	Contains(ctx context.Context, v Value) <span class="keyword">bool</span></span><br><span class="line">	Err() error</span><br><span class="line">	Reset()</span><br><span class="line">	Clone() Iterator</span><br><span class="line">	Stats() IteratorStats</span><br><span class="line">	Size() (<span class="keyword">int64</span>, <span class="keyword">bool</span>)</span><br><span class="line">	Type() Type</span><br><span class="line">	Optimize() (Iterator, <span class="keyword">bool</span>)</span><br><span class="line">	SubIterators() []Iterator</span><br><span class="line">	Close() error</span><br><span class="line">	UID() <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面最重要的迭代器方法就是</p>
<ul>
<li>Result() Value</li>
<li>Next(ctx context.Context) bool</li>
</ul>
<p>Next方法被这个迭代器用来执行内嵌在它自己内部的另一个迭代器 Result这个函数用来获取执行结果</p>
<p>那么我们会很好奇迭代器这么抽象是怎样最终转化为mongodb的查询语句的呢？因为在cayley中使用的mongodb连接第三方包就是mgo.v2</p>
<p>其实我们知道迭代是一层一层嵌套的 那么我们可以看一下最底层的迭代器的结构 最底层的迭代器如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	uid        <span class="keyword">uint64</span></span><br><span class="line">	tags       graph.Tagger</span><br><span class="line">	qs         *QuadStore</span><br><span class="line">	collection <span class="keyword">string</span></span><br><span class="line">	limit      <span class="keyword">int64</span></span><br><span class="line">	constraint []FieldFilter</span><br><span class="line">	links      []Linkage <span class="comment">// used in Contains</span></span><br><span class="line"></span><br><span class="line">	iter   DocIterator</span><br><span class="line">	result graph.Value</span><br><span class="line">	size   <span class="keyword">int64</span></span><br><span class="line">	err    error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个迭代是位于cayley源代码中的nosql\iterator.go中声明的迭代器 其中我们可以看到它包含一个字段</p>
<pre><code>constraint []FieldFilter
</code></pre><p>FieldFilter在cayley定义如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FieldFilter represents a single field comparison operation.</span></span><br><span class="line"><span class="keyword">type</span> FieldFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">	Path   []<span class="keyword">string</span> <span class="comment">// path is a path to specific field in the document</span></span><br><span class="line">	Filter FilterOp <span class="comment">// comparison operation</span></span><br><span class="line">	Value  Value    <span class="comment">// value that will be compared with field of the document</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Filter FilterO是一个用来表示比较的字段 有</p>
<ul>
<li>Equal</li>
<li>NotEqual</li>
<li>GT</li>
<li>GTE</li>
<li>LT</li>
<li>LTE</li>
</ul>
<p>Value  Value就是存储的节点值</p>
<p>语义上 上面这个结构体可以根据比较大小的操作符FilterOp和它的值value 来转化为在mongodb中对图的具体某个节点的查询</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/20/cayley原理2/" data-id="cjl22siut0005p0o0hxb0m411" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cayley/">cayley</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cayley原理一-获取查询结果" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/15/cayley原理一-获取查询结果/" class="article-date">
  <time datetime="2018-08-15T13:01:47.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/cayley原理一-获取查询结果/">cayley原理一(获取查询结果)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="查询结果的获取"><a href="#查询结果的获取" class="headerlink" title="查询结果的获取"></a>查询结果的获取</h2><p>首先我们假定cayley已将我们的查询语句path转化为mongodb的查询语句 现在我们分析cayley是如何从mongodb里面获取查询结果 并且返回给上层的</p>
<p>总体的结构如下(只包含从mongodb中获取查询结果 不包含解析为mongodb查询语句)<br><img src="http://static.zybuluo.com/gzm1997/ddaggos1xeyxb8nm3211m1d7/get.jpg" alt="get.jpg-67.1kB"></p>
<p>由cayley官方提供的hello world的查询方式如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := p.Iterate(<span class="literal">nil</span>).EachValue(<span class="literal">nil</span>, <span class="function"><span class="keyword">func</span><span class="params">(value quad.Value)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ignore</span></span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看见是调用了<strong>EachValue</strong>这个函数 这个函数是属于一个叫做<strong>IterateChain</strong>结构体的一个方法 如上提最左边的类 上图最左边是我们的顶层调用 越往右是底层调用</p>
<p>为了直观 我们从右边到左边 从底层到高层的调用如下</p>
<p> 1.mongo.go中的Iterator结构体(称为迭代器1)中调用Next()函数 这个Next()再调用mgo.v2\session.go中Iter结构体中的Next()函数 从而将从<strong>mgo</strong>中迭代的结果保存在迭代器1中的<strong>res字段</strong>中 这个字段类型是bson.M(实质上是一个map[string]interface{}类型) 然后迭代器1调用Doc()方法 将res类型转为Document(实质上为map[string]graph.Value)<br><img src="http://static.zybuluo.com/gzm1997/3cevje4c3hq094ifee3i02d7/image_1ckun71jb1l0s69khljmep15h2s.png" alt="image_1ckun71jb1l0s69khljmep15h2s.png-34.4kB"></p>
<p> 2.nosql\iterate.go中Iterator结构体(称为迭代器2)调用自己的Next()函数 进而调用步骤1中的迭代器1的Next()和Doc()函数完成步骤1的操作 并且转化为Document的结果存进迭代器2中的<strong>result字段</strong>中 类型是graph.Value<br><img src="http://static.zybuluo.com/gzm1997/o1y86b0ro82yi1clu3eotfrq/image_1ckun822b3bc14dec3k1u2pnvv39.png" alt="image_1ckun822b3bc14dec3k1u2pnvv39.png-60.3kB"></p>
<p> 3.iterate.go中的IterateChain结构体(称为迭代链)调用自己的Each()方法 进而 调用步骤2中的迭代器2中的Next()函数完成步骤2中的操作 并且使用迭代器2的Result()函数获取这个保存在迭代器2的Result字段中的结果<br><img src="http://static.zybuluo.com/gzm1997/zp9jikpfh9ok7gs7885n1p7i/image_1ckup1a0kv53hqeo1s1lb51c2ds.png" alt="image_1ckup1a0kv53hqeo1s1lb51c2ds.png-50.9kB"></p>
<hr>
<h2 id="使用接口实现多种实现方案"><a href="#使用接口实现多种实现方案" class="headerlink" title="使用接口实现多种实现方案"></a>使用接口实现多种实现方案</h2><p>上面图中的两部分绿色非常关键 两部分都是定义了很多方法的<strong>接口</strong> 我们称最右边的接口为接口1 另一个称为接口2</p>
<p>对于接口1来说<br>这些包含了若干方法的接口是声明在nosql.go中的DocIterator这个接口中的 并且被nosql\iterate.go中进行调用 在接口的具体实现上我们上面的方案是使用了mongo.go文件中的Iterator结构体实现方式 </p>
<p>试想一下：当我们实现另一个新的Iterator迭代器 并且都实现接口1的方法 但是在这些方法的定义上使用其他的nosql数据库进行底层存储 那么我就可以添加一种新的底层存储可选方案了</p>
<p>其实cayley可以使用mysql 还是mongodb bolt redis甚至内存等多种存储方式作为底层存储的原因就是：</p>
<blockquote>
<p>其实cayley在sql还是nosql类型方案的选择上就是通过<strong>接口2</strong>的实现方式不一样来实现的 而nosql方式的底层存储数据库到底选择何种nosql数据库也是通过<strong>接口1</strong>的实现方式不一样来实现的 sql具体数据库的选择也是类似</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/15/cayley原理一-获取查询结果/" data-id="cjl22siuv0007p0o0kpf300qt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cayley/">cayley</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-图数据库跟传统数据库以及图算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/09/图数据库跟传统数据库以及图算法/" class="article-date">
  <time datetime="2018-08-09T11:59:26.000Z" itemprop="datePublished">2018-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/09/图数据库跟传统数据库以及图算法/">图数据库跟传统数据库以及图算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么需要图数据库"><a href="#为什么需要图数据库" class="headerlink" title="为什么需要图数据库"></a>为什么需要图数据库</h2><ul>
<li>SQL依然是表哥数据的最好存储方式</li>
<li>s键值key-value依然是拓展性和速度上最快的</li>
<li>图数据库只是为我们提供了查询图状数据结构的一种方式</li>
</ul>
<p>为什么图状的数据结构的查询会对我们那么有用呢？<br>因为可以使用图状数据结构来表示人类可以直观理解的个体与个体之间的联系</p>
<p>但是为什么都使用其他的数据存储方式呢？</p>
<p>图数据库可以给你带来几样关键的好处</p>
<ol>
<li>可以更简单地表示更复杂的数据</li>
<li>可以更灵活地改变你要存储的关系 SQL都是需要预先定义模式的 所以当关系不断变化的时候 SQL相比图数据库的劣势就出来了</li>
<li>可以更易于自定义关系 两个节点之间的关系想怎么定义就怎么定义<br>4.可以支持一些设计图计算的算法 例如克鲁斯卡尔还有计算机网络的路由选路上涉及的一些算法</li>
</ol>
<p>后面好像就没讲什么了 都是讲一些cayley图数据库的一些基础跟查询相关的 没有我想要的一些设计原理和并发处理的一些内容</p>
<hr>
<h2 id="戴克斯克拉算法"><a href="#戴克斯克拉算法" class="headerlink" title="戴克斯克拉算法"></a>戴克斯克拉算法</h2><p>全局地寻找一个点到每个点的最短路径<br><img src="http://static.zybuluo.com/gzm1997/5u9ssmlowl90rcqcvsw9g5jk/image_1btdnlnnm15vk1omea11a2f1uth3a.png" alt="此处输入图片的描述"></p>
<h2 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h2><p>表示：<br>dx(y)x到y整条路径的最小cost<br><img src="http://static.zybuluo.com/gzm1997/sjsmxla9ylnnml9tyl7zw28e/image_1c3n2opou1sl4tfmv731mvt7bu9.png" alt="此处输入图片的描述"><br>x到y的路径的cost等于它先到邻居的cost加上邻居到y的最小cost<br><img src="http://static.zybuluo.com/gzm1997/0z153qoxt9t1fb10c9117b9n/image_1c3n2qnvi1r4f4brpffas14rpm.png" alt="此处输入图片的描述"></p>
<p>Bellman-Ford例子：<br><img src="http://static.zybuluo.com/gzm1997/yihmnjt2gaivr7zlfmi8f0wr/image_1c3n3hfes6vs1tv8gufhsjj1v9.png" alt="此处输入图片的描述"><br>要点：<br>Dx(y)是x到y的最小cost估计，N中每个节点都需要估计自己到y节点的最小cost。</p>
<p>每个节点中有一个距离向量<br>Dx = [Dx(y): y є N ]<br>这个距离向量包含着这个节点到N中所有节点最小cost的估计</p>
<p>而对于每个节点的邻居节点，也是这样：<br>Dv = [Dv(y): y є N ]</p>
<p>在距离向量算法下，每个节点需要维护的信息有：</p>
<ul>
<li>这个节点到邻居节点的cost</li>
<li>这个节点到N中每个节点的预计最小cost，也就是距离向量</li>
<li>这个节点邻居的距离向量</li>
</ul>
<p>算法：</p>
<ul>
<li>每段时间按之后，每个节点把自己的距离向量副本发送给自己的邻居</li>
<li>当每个节点接收到邻居发送过来的距离向量，拿这个距离向量更新自己的DV，使用BF公式</li>
</ul>
<p>DV算法例子： 注意每个节点定时需要更新和把它的距离向量广播给它的邻居<br><img src="http://static.zybuluo.com/gzm1997/5b8kzvkpk6xovf297hi7xmuo/image_1c3n4hcl41v761u62uqs1d3612e4m.png" alt="此处输入图片的描述"></p>
<p>LS和DV比较</p>
<ul>
<li>LS需要知道达到所有节点的cost，因此需要洪泛，但是DV不需要</li>
<li>LS的时间复杂度是O(N^2)，时间复杂度比DV更高</li>
</ul>
<hr>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树就是给一个图给你 每个点都是可以互相联通的 但是每条边的权重是不一样的 需要找出一堆边 使得这些点都连接起来 但是都不构成环 而且这些权重架起来还是最小</p>
<p><img src="http://static.zybuluo.com/gzm1997/7dc7aoj3zaj3om0ixf4fcfol/image_1ckf7ba5is713q9122mg2v1i2j1t.png" alt="image_1ckf7ba5is713q9122mg2v1i2j1t.png-58.1kB"></p>
<p>最小生成树一个很常见的应用场景是 城市之间需要铺电缆 每个城市之间都是可以铺的 但是不同城市之间铺设电缆的成本不一样 那么就需要我们找出一个满足要求的最小生成树 来让成本最低</p>
<p>找最小生成树的方法 一般有<strong>Kruskal克鲁斯卡尔算法</strong></p>
<p>步骤</p>
<ol>
<li>新建图G，G中拥有原图中相同的节点，但没有边</li>
<li>将原图中所有的边按权值从小到大排序</li>
<li>从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中</li>
<li>重复3，直至图G中所有的节点都在同一个连通分量中</li>
</ol>
<p>维基百科上给的例子 非常容易理解<br><img src="http://static.zybuluo.com/gzm1997/e2nr8mfyklmpu8wt776j7jux/image_1ckf7k3dbke01d0di4017nm1r0j2a.png" alt="image_1ckf7k3dbke01d0di4017nm1r0j2a.png-158.7kB"></p>
<p>就是先找出一个图的所有的边 按照权重从小到大排序 一次选取权重最小的边 添加到结果图中 注意会跟已经选到的边构成环的边不要选择 抛弃就可以 知道图中的所有节点都在一个连通分量中</p>
<hr>
<h2 id="上面两种图的算法"><a href="#上面两种图的算法" class="headerlink" title="上面两种图的算法"></a>上面两种图的算法</h2><p>其实上面我们要搞清楚<br>寻找最小生成树的算法 </p>
<blockquote>
<p>克鲁斯卡尔算法是寻找整个图的边权重之和最小的一种方法 <strong>寻找最小生成树</strong></p>
</blockquote>
<p>但是上面的两种算法 1.戴克斯克拉算法 2.距离向量算法 这两个算法都是路由选路算法 </p>
<blockquote>
<p>路由选路算法最终找到的结果并不是最小生成树 而是<strong>一个点到其它点距离最小的路径集合</strong> 注意这个<strong>不一定是最小生成树</strong>的</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/09/图数据库跟传统数据库以及图算法/" data-id="cjl22sivu001ip0o0zksjji1y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图数据库/">图数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图算法/">图算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-使用rabbitMQ作为缓存队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/08/使用rabbitMQ作为缓存队列/" class="article-date">
  <time datetime="2018-08-08T09:50:59.000Z" itemprop="datePublished">2018-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/08/使用rabbitMQ作为缓存队列/">使用rabbitMQ作为缓存队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="高并发请求情况"><a href="#高并发请求情况" class="headerlink" title="高并发请求情况"></a>高并发请求情况</h2><p>我们在服务端开发过程中 往往会遇到需要处理高并发请求 并且将post过来的数据存进数据库的情况 这种情况一般会对我们的两部分造成很大压力</p>
<ol>
<li>nginx等服务器</li>
<li>数据库连接</li>
</ol>
<p>因为当并发量很大的时候 nginx等服务器会因为负载均衡受不了那么大的压力会崩掉 一般这样的话</p>
<blockquote>
<p>用Unix socket或者tcp socket的方式增多几个web app实例以供nginx进行轮训 或者配置一下nginx的最大连接数 这样一般可以有效解决nginx服务器的问题</p>
</blockquote>
<p>但是数据库的操作这边是无论如何也是需要一点时间的 如果并发量很大 那么久比较难解决 一般来说mongodb是可以通过在公有的连接池里面拷贝出一个新的session 但是这样的效果也是有限的 而比较有效的方法是</p>
<blockquote>
<p>使用<strong>消息队列</strong>暂时存储来不及处理的数据 等服务端缓过来之后再冲消息队列里面获取数据 进行数据库操作</p>
</blockquote>
<hr>
<h2 id="rabbitMQ"><a href="#rabbitMQ" class="headerlink" title="rabbitMQ"></a>rabbitMQ</h2><p>rabbitMQ就是一个缓存队列 下面是一个缓存队列的基本结构</p>
<p><img src="http://static.zybuluo.com/gzm1997/dwrbzl5k4m7bfsny7b1bc1n9/image_1ckc8btt31eftpo66tvgja139e9.png" alt="image_1ckc8btt31eftpo66tvgja139e9.png-73kB"></p>
<p>交换区 bindingKey跟queue构成channel</p>
<p>1.生产者<br>第一部分是生产者并，生产者不知道到底有什么队列可以存东西 只是一个单纯的搬运工 将打上了bindingKey的信息转发给第二部分exchange交换区</p>
<p>2.交换区<br>第二部分是交换区 交换区位于生产者和队列之间 所有的消息都是由交换区转发给队列的 转发给队列之间需要进行<strong>QueueBind队列绑定</strong> 类似下面<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">err = ch.QueueBind(</span><br><span class="line">    <span class="comment">//用来接收信息的queue的名字</span></span><br><span class="line">	q.Name,</span><br><span class="line">	<span class="comment">//bingdingKey是什么</span></span><br><span class="line">	b.String(),</span><br><span class="line">	<span class="comment">//交换区是什么</span></span><br><span class="line">	EXCHANGE,</span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>简而言之 队列绑定就是当接收方声明一个队列作为接收队列的时候 用来说明 打上了什么样的bingdingKey的信息应该从交换区那边转发给给我这个队列里面 然后随后我自己会从这个队列里面拿出这些信息</p>
<p>3.队列<br>第三部分是队列 就是作为存储的空间 所有有待被接收方接收的信息都存储在这些队列里面 当一个信息被接收方接收成功之后 队列会删除这个信息以释放内存 如果接收方没有成功接收 <strong>那么这个信息会在队列里面重新排队 如果刚好有空闲的队列 那么这个信息会接着很快被处理</strong> 但是这里涉及到一个问题</p>
<blockquote>
<p>队列是怎样知道接收方成功接收了信息呢？</p>
</blockquote>
<p><a href="#%E9%98%9F%E5%88%97%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E6%8E%A5%E6%94%B6%E6%96%B9%E6%88%90%E5%8A%9F%E6%8E%A5%E6%94%B6">详情如下</a></p>
<blockquote>
<p>但是一旦发送方这边挂了 怎么办呢？</p>
</blockquote>
<p><a href="#%E5%8F%91%E9%80%81%E6%96%B9%E4%B8%8D%E5%B0%8F%E5%BF%83%E6%8C%82%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E">详情如下</a></p>
<blockquote>
<p>公平分发 有时候有些种情况是当exchange类型是默认类型的话 需要分发信息12345 奇数的信息需要处理的时间更久一点 偶数处理时间比较短 那么还是轮流来分配对于第一个消费者来书是不公平的</p>
</blockquote>
<p><a href="#%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91">如何实现公平分发</a></p>
<p>4.消费者<br>第四部分是消费者 消费者是可以多个的 消息队列的一个很大的好处是平行化工作 设想一下有一种情况是生产者不断生产工作 发送到队列里面 多个消费者从队列里面获取工作信息进行工作 这样的话可以大到<strong>平行化工作</strong>的效果 最大使用服务端这边的资源</p>
<hr>
<h2 id="exchange类型"><a href="#exchange类型" class="headerlink" title="exchange类型"></a>exchange类型</h2><p>exchange的集中类型</p>
<ul>
<li>默认类型 用一个””空字符串进行声明 在publish发送信息的时候需要指定一个队列的名字进行转发 如果有多个队列名字一样的接收方 那么将进行轮训转发 例如有12345需要转发 有两个队列名字一样的接收方 那么一个接受135 一个接受24</li>
<li>fanout 扇出类型 将信息发给所有可用的队列</li>
<li>direct类型 direct类型根据唯一的bindingKey将信息转发到进行了队列绑定的队列上 通俗地说就是打上了一个标签的信息会被转发到唯一的一个队列上</li>
<li>topic类型 topic类型是direct类型的进化版本 每个队列可以匹配一个或者多个标签</li>
</ul>
<p>各种类型的交换区的使用方法有点啰嗦 这里就不讲了 可以去看官方文档 文档比较多例子 通俗易懂<br><a href="https://www.rabbitmq.com/tutorials/tutorial-one-go.html" target="_blank" rel="noopener">rabbitMQ go文档</a></p>
<p>但是后面我会拿我这次在用户关系图谱这个项目上使用的rabbitMQ作为例子 我使用了direct类型的exchange</p>
<p><a href="#rabbitMQ%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8A%E4%BD%BF%E7%94%A8">rabbitMQ在服务端上使用</a></p>
<hr>
<h2 id="队列怎么知道接收方成功接收"><a href="#队列怎么知道接收方成功接收" class="headerlink" title="队列怎么知道接收方成功接收"></a>队列怎么知道接收方成功接收</h2><p>这里跟计算机网络里面的ACK是类似的 当接收方成功接收到了一个信息 会为这个信息给队列发送一个ACK信号说明我成功接收到了这个信息 在官方文档的hello world里面是设置了默认的自动发送ACK信号<br><img src="http://static.zybuluo.com/gzm1997/5ai5z53e3ihu8s16jb301ndv/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180808161057.png" alt="微信图片_20180808161057.png-13kB"></p>
<p><strong>这个ACK机制其实是为了预防接收方挂了 因为一旦接收方不小心挂了 那么发送方这边就接收不到ACK信号 从而重新给那个信息排队</strong> </p>
<p>你也可以设置autoAck为false 然后自己在接收方那边使用</p>
<pre><code>d.Ack(false)
</code></pre><p>来进行发送ACK信号</p>
<hr>
<h2 id="发送方不小心挂了怎么办"><a href="#发送方不小心挂了怎么办" class="headerlink" title="发送方不小心挂了怎么办"></a>发送方不小心挂了怎么办</h2><p>这就设置<strong>可靠性</strong>的设置了 </p>
<p>首先需要设置队列是可靠的 durable可靠性这个选项是需要在服务端和客户端两边都需要设置的<br><img src="http://static.zybuluo.com/gzm1997/mrzrjp2t2ty8zd9bczd2c4qp/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180808161610.png" alt="微信图片_20180808161610.png-9.2kB"></p>
<p>然后设置我们的信息是<strong>persistent持久的</strong><br><img src="http://static.zybuluo.com/gzm1997/ygb92cd0g9voxjani3wfckyl/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180808161855.png" alt="微信图片_20180808161855.png-9.2kB"></p>
<p>上面两个设置可以有效防止发送方这边挂了的情况 这样即使发送方不小心崩溃了 在重启之后也会重新发送还没发送成功的信息</p>
<hr>
<h2 id="公平分发"><a href="#公平分发" class="headerlink" title="公平分发"></a>公平分发</h2><p>有时候有些种情况是当exchange类型是默认类型的话 需要分发信息12345 奇数的信息需要处理的时间更久一点 偶数处理时间比较短 那么还是轮流来分配对于第一个消费者来书是不公平的<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err = ch.Qos(</span><br><span class="line">  <span class="number">1</span>,     <span class="comment">// prefetch count</span></span><br><span class="line">  <span class="number">0</span>,     <span class="comment">// prefetch size</span></span><br><span class="line">  <span class="literal">false</span>, <span class="comment">// global</span></span><br><span class="line">)</span><br><span class="line">failOnError(err, <span class="string">"Failed to set QoS"</span>)</span><br></pre></td></tr></table></figure></p>
<p>其实这样设置一下就可以了 这样表明队列是不会一次性地给一个消费者分发超过一个的消息 直到消费者处理完并且发送了前一个信息的ack信号之后再分发 或者将这个信息发送给下一个不是很忙的消费者</p>
<hr>
<h2 id="rabbitMQ在服务端上使用"><a href="#rabbitMQ在服务端上使用" class="headerlink" title="rabbitMQ在服务端上使用"></a>rabbitMQ在服务端上使用</h2><p>项目部分代码地址<br><a href="https://github.com/gzm1997/graph-relation/tree/master/graphServer" target="_blank" rel="noopener">用户关系图谱路由server</a></p>
<p>其中rabbitMQ主要使在cache模块<br><a href="https://github.com/gzm1997/graph-relation/blob/master/graphServer/cache/rabbit.go#L18-L47" target="_blank" rel="noopener">进行rabbit的初始化</a><br>一定要注意如果你是在init函数中进行rabbit的初始化的话一定不要在init函数了里面使用defer进行关闭连接跟channel 因为这样的话后面要使用rabbit资源就会报错显示连接或者channel断开 rabbit资源的释放需要在其后关闭 最好需要关闭<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//加载rabbitMQ在配置文件中的配置</span></span><br><span class="line">	rabbitUser := beego.AppConfig.String(<span class="string">"rabbitUser"</span>)</span><br><span class="line">	rabbitPsw := beego.AppConfig.String(<span class="string">"rabbitPsw"</span>)</span><br><span class="line">	rabbitIp := beego.AppConfig.String(<span class="string">"rabbitIp"</span>)</span><br><span class="line">	rabbitPort, _ := beego.AppConfig.Int(<span class="string">"rabbitPort"</span>)</span><br><span class="line">	dbUrl := fmt.Sprintf(<span class="string">"amqp://%s:%s@%s:%d/"</span>, rabbitUser, rabbitPsw, rabbitIp, rabbitPort)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="comment">//建立链接</span></span><br><span class="line">	<span class="keyword">if</span> conn, err = amqp.Dial(dbUrl); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明一个channel</span></span><br><span class="line">	<span class="keyword">if</span> ch, err = conn.Channel(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明一个类型为direct的交换区</span></span><br><span class="line">	err = ch.ExchangeDeclare(</span><br><span class="line">		EXCHANGE,</span><br><span class="line">		<span class="string">"direct"</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发布新消息<br><a href="https://github.com/gzm1997/graph-relation/blob/master/graphServer/cache/rabbit.go#L49-L65" target="_blank" rel="noopener">发布信息</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PublishMsg</span><span class="params">(json []<span class="keyword">byte</span>, bingdingKey BindingKey)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := ch.Publish(</span><br><span class="line">		<span class="comment">//指定我们要使用的direct类型的交换区</span></span><br><span class="line">		EXCHANGE,</span><br><span class="line">		<span class="comment">//根据bingdingKey进行转发</span></span><br><span class="line">		bingdingKey.String(),</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			<span class="comment">//发送的信息时候持久的 即使发送方突然挂了 重启之后还会继续发</span></span><br><span class="line">			DeliveryMode: amqp.Persistent,</span><br><span class="line">			<span class="comment">//发送的类型是json对象</span></span><br><span class="line">			ContentType: <span class="string">"application/json"</span>,</span><br><span class="line">			Body: json,</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接受信息<br><a href="https://github.com/gzm1997/graph-relation/blob/master/graphServer/cache/rabbit.go#L67-L195" target="_blank" rel="noopener">接受信息</a><br>接收方因为用户关系图谱这个项目的逻辑比较复杂 所以写的说起来有点麻烦 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMsg</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//在这里释放rabbit的资源</span></span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="keyword">defer</span> ch.Close()</span><br><span class="line">	forever := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, bingdingKey := <span class="keyword">range</span> AllBindingKeys &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(b BindingKey)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"queue for"</span>, b)</span><br><span class="line">			<span class="comment">//声明一个匿名队列</span></span><br><span class="line">			q, err := ch.QueueDeclare(</span><br><span class="line">				<span class="string">""</span>,</span><br><span class="line">				<span class="literal">true</span>,</span><br><span class="line">				<span class="literal">false</span>,</span><br><span class="line">				<span class="literal">true</span>,</span><br><span class="line">				<span class="literal">false</span>,</span><br><span class="line">				<span class="literal">nil</span>,</span><br><span class="line">			)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//进行队列绑定</span></span><br><span class="line">			err = ch.QueueBind(</span><br><span class="line">				q.Name,</span><br><span class="line">				b.String(),</span><br><span class="line">				EXCHANGE,</span><br><span class="line">				<span class="literal">false</span>,</span><br><span class="line">				<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//声明一个消费者 从这个匿名队列里面读取信息</span></span><br><span class="line">			msgs, err := ch.Consume(</span><br><span class="line">				q.Name, <span class="comment">// queue</span></span><br><span class="line">				<span class="string">""</span>,     <span class="comment">// consumer</span></span><br><span class="line">				<span class="literal">false</span>,   <span class="comment">// auto ack</span></span><br><span class="line">				<span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">				<span class="literal">false</span>,  <span class="comment">// no local</span></span><br><span class="line">				<span class="literal">false</span>,  <span class="comment">// no wait</span></span><br><span class="line">				<span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">			)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			store := session.GetGraph()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> b &#123;</span><br><span class="line">			<span class="keyword">case</span> CreateGroupShareLink:</span><br><span class="line">				<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">					cgsl := models.CreateGroupShareLink&#123;&#125;</span><br><span class="line">					<span class="keyword">if</span> err := json.Unmarshal(d.Body, &amp;cgsl); err == <span class="literal">nil</span> &#123;</span><br><span class="line">						fmt.Println(<span class="string">"add CreateGroupShareLink"</span>, cgsl)</span><br><span class="line">						fmt.Println(cgsl.AddCreateGroupShareLinkToCayley(store))</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="built_in">panic</span>(err)</span><br><span class="line">					&#125;</span><br><span class="line">				    <span class="comment">//发送ack信号 代表已经接受成功</span></span><br><span class="line">					d.Ack(<span class="literal">false</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="comment">//省略部分 太长省略</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(bingdingKey)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;- forever</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="释放rabbit资源"><a href="#释放rabbit资源" class="headerlink" title="释放rabbit资源"></a>释放rabbit资源</h2><p>如果没有释放rabbit的资源 而且设置了channel和queue为可靠以及持久性的话 一般会导致一个bug</p>
<blockquote>
<p>receiveed unexpected response</p>
</blockquote>
<p>这是因为有可能在你挑食的时候突然关闭 而你却没有在代码里面主动close掉connection和channel 那么下一次运行的时候 接收方会重新发送一次一个信息 这导致发送方不知道这是什么ACK的信息 从而导致这个报错 一般来说<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这里释放rabbit的资源</span></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">defer</span> ch.Close()</span><br></pre></td></tr></table></figure></p>
<p>可以有效解决这个问题 但是还是会偶尔出现的 出现的话就重新开几次 两三次之后缓存被清理掉就没有这个报错了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/08/使用rabbitMQ作为缓存队列/" data-id="cjl22sivq001bp0o0xil0t3ul" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rabbitMQ/">rabbitMQ</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mux学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/06/mux学习/" class="article-date">
  <time datetime="2018-08-06T08:19:39.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/mux学习/">mux学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="mux简介"><a href="#mux简介" class="headerlink" title="mux简介"></a>mux简介</h2><blockquote>
<p>mux implement了一个请求路由器和调度符合要求的输入请求到相应的视图函数中，mux是http request multiplexer 就是http多路复用器 </p>
</blockquote>
<p>mux的特点是</p>
<ul>
<li>implement了http.Handler接口 因此跟http.ServeMux是兼容的</li>
<li>请求可以基于URL path path前缀 协议 头部 还有请求参数 http方法 或者使用客制的匹配器</li>
<li>URL host， path 还有query values可以使用正则表达式来匹配变量</li>
<li>注册URL可以被构造 或者”反向” 这样有助于维护队资源的引用</li>
<li>可以使用子路由 嵌套路由只有当父路由被匹配之后才会被指向 有利于路由的分类 以及在视图函数的编写上遵循模块化编程的准则</li>
</ul>
<hr>
<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><pre><code>go get -u github.com/gorilla/mux
</code></pre><hr>
<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">	w.Write([]<span class="keyword">byte</span>(<span class="string">"lalalala"</span>))</span><br><span class="line">	w.WriteHeader(http.StatusOK)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	r := mux.NewRouter()</span><br><span class="line">	<span class="comment">//r.Host("localhost")</span></span><br><span class="line">	r.HandleFunc(<span class="string">"/test"</span>, test)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">"localhost:8080"</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>声明一个路由</p>
<pre><code>r := mux.NewRouter()
</code></pre><p>注册视图函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/products/&#123;key&#125;"</span>, ProductHandler)</span><br><span class="line">r.HandleFunc(<span class="string">"/articles/&#123;category&#125;/"</span>, ArticlesCategoryHandler)</span><br><span class="line">r.HandleFunc(<span class="string">"/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;"</span>, ArticleHandler)</span><br></pre></td></tr></table></figure></p>
<p>注意到上面的URL匹配那里是可以使用正则表达式来进行匹配变量的</p>
<p>视图函数编写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArticlesCategoryHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    vars := mux.Vars(r)</span><br><span class="line">    w.WriteHeader(http.StatusOK)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Category: %v\n"</span>, vars[<span class="string">"category"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>视图函数或者说handler都是两个默认参数</p>
<ol>
<li>w http.ResponseWriter</li>
<li>r *http.Request</li>
</ol>
<p>要注意第二http.request请求的参数<strong>指针类型</strong>的 不要写错 其它跟Java的servlet基本相同 <strong>使用writer讲返回内容输出到http response中</strong> 但是要注意视图函数都是void类型 没有返回值</p>
<hr>
<h2 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h2><p>匹配域名</p>
<pre><code>r.Host(&quot;www.example.com&quot;)
</code></pre><p>匹配一个动态的子域名 可以使用正则</p>
<pre><code>r.Host(&quot;{subdomain:[a-z]+}.domain.com&quot;)
</code></pre><p>匹配URL前缀</p>
<pre><code>r.PathPrefix(&quot;/products/&quot;)
</code></pre><p>匹配http方法</p>
<pre><code>r.Methods(&quot;GET&quot;, &quot;POST&quot;)
</code></pre><p>匹配协议</p>
<pre><code>r.Schemes(&quot;https&quot;)
</code></pre><p>匹配头部</p>
<pre><code>r.Headers(&quot;X-Requested-With&quot;, &quot;XMLHttpRequest&quot;)
</code></pre><p>匹配查询参数</p>
<pre><code>r.Queries(&quot;key&quot;, &quot;value&quot;)
</code></pre><p>使用客制匹配器<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.MatcherFunc(<span class="function"><span class="keyword">func</span><span class="params">(r *http.Request, rm *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.ProtoMajor == <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面的各种匹配是可以一起声明的 向下面这样<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/products"</span>, ProductsHandler).</span><br><span class="line">  Host(<span class="string">"www.example.com"</span>).</span><br><span class="line">  Methods(<span class="string">"GET"</span>).</span><br><span class="line">  Schemes(<span class="string">"http"</span>)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="mux路由匹配冲突问题"><a href="#mux路由匹配冲突问题" class="headerlink" title="mux路由匹配冲突问题"></a>mux路由匹配冲突问题</h2><blockquote>
<p>如果一个请求跟两个路由都匹配 这就造成了冲突 这时候第一个会被成功匹配</p>
</blockquote>
<hr>
<h2 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h2><blockquote>
<p>子路由不仅仅很方便 而且有利于优化代码</p>
</blockquote>
<p>例子<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">	w.Write([]<span class="keyword">byte</span>(<span class="string">"lalalala"</span>))</span><br><span class="line">	w.WriteHeader(http.StatusOK)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSubRouter</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">	w.Write([]<span class="keyword">byte</span>(<span class="string">"this is subrouter page"</span>))</span><br><span class="line">	vars := mux.Vars(r)</span><br><span class="line">	key := vars[<span class="string">"key"</span>]</span><br><span class="line">	w.Write([]<span class="keyword">byte</span>(key))</span><br><span class="line">	w.WriteHeader(http.StatusOK)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	r := mux.NewRouter()</span><br><span class="line">	s := r.PathPrefix(<span class="string">"/hello"</span>).Subrouter()</span><br><span class="line">	s.HandleFunc(<span class="string">"/&#123;key&#125;"</span>, testSubRouter)</span><br><span class="line">	r.HandleFunc(<span class="string">"/test"</span>, test)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">"localhost:8080"</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><blockquote>
<p>静态文件在mux中一般使用static的url前缀来匹配 这样非常方便</p>
</blockquote>
<hr>
<p>未完待续！</p>
<p><a href="https://github.com/gorilla/mux" target="_blank" rel="noopener">参考链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/06/mux学习/" data-id="cjl22sivd000sp0o0osk634ah" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mux/">mux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-go-web" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/06/go-web/" class="article-date">
  <time datetime="2018-08-06T08:18:40.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/go-web/">go web</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://golang.org/doc/articles/wiki/ttps://golang.org/doc/articles/wiki/" target="_blank" rel="noopener">参考链接</a><br>这个教程是原生的库<strong>net/http</strong>来进行web服务端开发的 教程中使用了<strong>html/template</strong>来加载HTML模板 模板的语法也跟Python的jinja2的数据绑定很类似 但是我们清楚这种前后端不分离的方式其实不再合适未来的趋势</p>
<hr>
<h2 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h2><p>go原生的<strong>net/http</strong>比较有意思 它的视图函数没有返回值也是可以的 它的<strong>http.HandleFunc</strong>这个装饰器可以默认返回空 不会报错 相反Python的一些框架就不行</p>
<p>一般视图函数格式 <strong>http.ResponseWriter</strong>用来写入返回给客户端的头部信息或者[]byte类型数据 <strong>*http.Request</strong>注意是一个指针类型 其实这里我有点不是很明白 怎么request是按照指针传递 response是按照值传递？</p>
<blockquote>
<p>我自己觉得应该是在go语言中 response是从开发人员自己生命定义的handle视图函数开始就被一层一层的wrapper包装 所以response是不断被层层包裹被修改的 在每一层wrapper中response都不一样 所以按值传递就可以 但是requestsh1i是在各层wrapper或者redirect过程中都需要保持不变的 因为request是的参数被修改的话会影响http response这样没有太大意义 所以request最好使用指针传递 原来的request该怎样就怎样</p>
</blockquote>
<p>stackoverflow的上关于这个问题的解释是</p>
<ul>
<li>http.request是一个很大的结构 值拷贝的话花销非常大</li>
<li>http.request是含有一些状态state的 如果被拷贝的话具有一定的迷惑性</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">	p := r.URL.Path</span><br><span class="line">	fmt.Println(<span class="string">"path"</span>, p)</span><br><span class="line">	w.Write([]<span class="keyword">byte</span>(<span class="string">"lalallallala"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="注册视图函数"><a href="#注册视图函数" class="headerlink" title="注册视图函数"></a>注册视图函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="运行web后端app"><a href="#运行web后端app" class="headerlink" title="运行web后端app"></a>运行web后端app</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>上面是不会打印输出任何内容的 所以一般下面这样运行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure></p>
<p>一般ip地址是可以被忽略的 默认是本机的IP地址</p>
<p>一般来说我们希望运行多个实例 然后在nginx上可以设置负载均衡 但是刚刚说上面那个监听运行语句是阻塞的 所以go语言这种天生支持多线程的的语言的优势就派上用场了</p>
<p>可以使用goroutine多开线程运行多个web app<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 4; i++ &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		log.Fatal(http.ListenAndServe(&quot;:808&quot; + string(i), nil))</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>html模板加载和渲染就不记录了 就是使用原生的html/template这个库 语法非常类似Python的jinja2 感觉这部分在日益前后端分离的今天有点不合时宜了 所以只是看了看 没有多加记录</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/06/go-web/" data-id="cjl22siv6000ip0o0tjzzbtzx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-go多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/06/go多线程/" class="article-date">
  <time datetime="2018-08-06T08:17:50.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/go多线程/">go多线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote>
<p><strong>go是默认一个核只在一个时间点只可以运行一个线程</strong> 如果要实现并发 需要告诉go我们允许同时使用多个核 这样才可以实现真正意义上的并发</p>
</blockquote>
<hr>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><blockquote>
<p>go语言可以使用go开始执行一个新的线程 完果没有go的语句就跟正常一样 当所有的代码执行完毕而还有goroutine还没执行完 那么那些线程都会被终止 </p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">go</span> fmt.Println(<span class="string">"lalala"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"hahaha"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的情况是 其实只用了一个核 所有这不是并行 这是并发 那么输出结果是取决于那个goroutine结束最快 第二行输出结束最快(这里跟异步的感觉有点像) 那么输出是第二行 然后第二行运行结束之后 就终止了所有的goroutine 这时候第一行就来不及执行了 第一行等不到结束就被终止了</p>
<p>如果需要两行都输出 那么需要sleep一下 当第二行执行完的时候 这时候sleep会释放出CPU资源 这时候第一行可以使用CPU资源进行执行输出结果<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">go</span> fmt.Println(<span class="string">"lalala"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"hahaha"</span>)</span><br><span class="line">	time.Sleep(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/27at0en69mz01xnc8wmqb7dl/image_1chi83vnr1r2417ginpa12s9118c9.png" alt="image_1chi83vnr1r2417ginpa12s9118c9.png-14kB"></p>
<p>goroutine应用在func上<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">publicMews</span><span class="params">(text <span class="keyword">string</span>, delay time.Duration)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(delay)</span><br><span class="line">		fmt.Println(<span class="string">"breaking news"</span>, text)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"after func"</span>)</span><br><span class="line">	time.Sleep(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	publicMews(<span class="string">"world cup"</span>, <span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果跟上面类似</p>
<hr>
<h2 id="管道的基本使用"><a href="#管道的基本使用" class="headerlink" title="管道的基本使用"></a>管道的基本使用</h2><p>声明管道</p>
<p>声明双向的无缓存管道</p>
<pre><code>test := make(chan int)
</code></pre><p>声明双向的有缓存管道</p>
<pre><code>test2 := make(chan int, 10)
</code></pre><p>创建只写管道</p>
<pre><code>test3 := make(chan &lt;- int)
</code></pre><p>创建只读管道</p>
<pre><code>test4 := make(&lt;- chan int)
</code></pre><p>也可以声明通道是指针类型</p>
<pre><code>test5 := make(&lt;- chan *int)
</code></pre><hr>
<h2 id="使用管道在线程之间进行通信"><a href="#使用管道在线程之间进行通信" class="headerlink" title="使用管道在线程之间进行通信"></a>使用管道在线程之间进行通信</h2><blockquote>
<p>当一个管道被声明之后 它是开着的 如果没有信息传进去 那么等待管道的线程一直等不到输出 会陷入<strong>死锁</strong></p>
</blockquote>
<p>只要另外一个线程的管道没有被正确关闭 那么主线程会一直等待 这样会陷入死锁</p>
<p>像下面这样<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">fmt.Println(&lt;- ch)</span><br></pre></td></tr></table></figure></p>
<p>输出显示死锁<br><img src="http://static.zybuluo.com/gzm1997/5vwb6qowab7adku5ydxei5n4/image_1chiabekv14kl1lat12lm1nqkmlf1m.png" alt="image_1chiabekv14kl1lat12lm1nqkmlf1m.png-31.7kB"></p>
<p>但是即使我们没有在管道中输入信息 但是及时关闭了管道 这样是可以避免出现死锁的出现的</p>
<p>像下面这样<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">fmt.Println(&lt;- ch)</span><br></pre></td></tr></table></figure></p>
<p>这样就没有造成死锁问题了</p>
<p>下面的例子 第一次发送之后我们关闭这个管道 那么第一次接受是可以接受到发送过来的内容的 然后因为我们关闭了这个管道 那么接下来的输出都是输出空字符串 同时因为已经正确关闭了管道 所以不会出现上述的死锁问题<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- <span class="string">"lalalalla"</span></span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(&lt;- ch)</span><br><span class="line">	fmt.Println(&lt;- ch)</span><br><span class="line">	fmt.Println(&lt;- ch)</span><br><span class="line">	a, b := &lt;- ch</span><br><span class="line">	fmt.Println(<span class="string">"a"</span>, a, <span class="string">"b"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/psk23n5ldscvz2xf6ftctez3/image_1chib44pt1faa1t1crb81v2a22j23.png" alt="image_1chib44pt1faa1t1crb81v2a22j23.png-16.9kB"></p>
<p>管道使用的时候一定要注意发送方和接受方一定要处于两个不同的线程 如果处于一个线程 会有一个莫名其妙的死锁报错</p>
<p>像下面这样<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMsgToCh</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">			ch &lt;- i</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	r := sendMsgToCh(ch)</span><br><span class="line">	<span class="keyword">for</span> c := <span class="keyword">range</span> r &#123;</span><br><span class="line">		fmt.Println(<span class="string">"receive value"</span>, c)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>报错<br><img src="http://static.zybuluo.com/gzm1997/4rubaa0xtc5om2akc66vdvn5/image_1chk2d6gp1ffs16mg1o0hniitqe39.png" alt="image_1chk2d6gp1ffs16mg1o0hniitqe39.png-164.9kB"></p>
<hr>
<h2 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h2><p>其实就是公有变量的互斥性访问问题 这个设置互斥锁问题</p>
<p>例如下面<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		n++</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	n++</span><br><span class="line">	time.Sleep(<span class="number">3</span>)</span><br><span class="line">	fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果是 如果没有sleep三秒 那么输出一般都是1的 如果sleep之后输出是2 所以可见两个线程都是在做自增n的操作的</p>
<p><strong>避免数据竞争的唯一方式是线程间同步访问所有的共享可变数据</strong></p>
<p>在go语言中 这一般都是使用</p>
<ul>
<li>管道</li>
<li>锁</li>
</ul>
<p>有句话说的好 </p>
<blockquote>
<p>不要通过共享内存来通讯 而是通过通讯来共享内存(共享变量)</p>
</blockquote>
<p>通过管道来实现两个线程同步修改公有变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		n++</span><br><span class="line">		ch &lt;- n</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	r := &lt;- ch</span><br><span class="line">	r++</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>向上面说的 出了使用管道来在进程间进行数据传输 还可以使用同步锁实现公有变量的互斥访问</p>
<p>下面是使用同步锁来让两个线程都自增一个公有变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AutomicInt <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AutomicInt)</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a.mu.Lock()</span><br><span class="line">	a.val++</span><br><span class="line">	a.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a AutomicInt)</span> <span class="title">get</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	a.mu.Lock()</span><br><span class="line">	r := a.val</span><br><span class="line">	a.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	mu := sync.Mutex&#123;&#125;</span><br><span class="line">	a := AutomicInt&#123;mu, <span class="number">0</span>&#125;</span><br><span class="line">	wait := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		a.add()</span><br><span class="line">		<span class="built_in">close</span>(wait)</span><br><span class="line">	&#125;()</span><br><span class="line">	a.add()</span><br><span class="line">	&lt;- wait</span><br><span class="line">	r := a.get()</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/0rh0ahsjyrgn7qttciu9nnhd/image_1chk4qjrm2d31ljs4ve1nq56cf9.png" alt="image_1chk4qjrm2d31ljs4ve1nq56cf9.png-15.8kB"></p>
<hr>
<p>WaitGroup<br>相当于Python asyncio的eventloop 都是讲线程添加到一个队列进行阻塞运行 直至运行完毕 有几个函数要注意一下</p>
<p>声明一个waitgroup 并制定可以放1五个线程进去</p>
<pre><code>wg := sync.WaitGroup{}
wg.Add(5)
</code></pre><p>上面这样声明之后 这个waitgroup的计数器就是5了 每当我们执行一个线程 需要在后面加上</p>
<pre><code>wg.Done()
</code></pre><p>done函数会使得计数器-1 计数器减少到0之后就执行完毕</p>
<p>使用waitgroup进行多个线程互斥访问公有变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"i"</span>, i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	race()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出是55555 这个结果很显然的了 就是for循环上的自增是先被执行的 后面的线程才被执行 那么所有线程输出的i都是5</p>
<p>可以在线程的匿名函数参数表chuan将公有变量作为参数穿进去 这样输出的结果才是对的 但是顺序肯定是乱的 因为线程的执行真的是顺序根本不确定的</p>
<p>如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"i"</span>, i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	race()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果<br><img src="http://static.zybuluo.com/gzm1997/sdcsknbhgi8fdo50m65zlvk1/image_1chk5lond1u2k1vh68oj12glooq1m.png" alt="image_1chk5lond1u2k1vh68oj12glooq1m.png-15.8kB"></p>
<hr>
<h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>golang的select跟select poll epoll相似 就是监听io操作 当思io操作发生时 触发相应的动作</p>
<p>注意select代码形式跟switch非常相似 但是select的case里操作语句只能是io操作</p>
<p>例子<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	c1, c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">//var i1, i2 int</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		c1 &lt;- <span class="number">12</span></span><br><span class="line">		<span class="built_in">close</span>(c1)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		c2 &lt;- <span class="number">23</span></span><br><span class="line">		<span class="built_in">close</span>(c2)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> i1 := &lt;- c1: fmt.Println(<span class="string">"r 1"</span>, i1)</span><br><span class="line">	<span class="keyword">case</span> i2 := &lt;- c2: fmt.Println(<span class="string">"r 2"</span>, i2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码可以输出第一个 也可以额输出第二个 这样取决于哪个线程最先完成 select是一定要等到其中一个case有io操作 就是有数据传输过来的 再次之前一直阻塞</p>
<p>但是一直没有io语句执行成功 而且select含有default语句的时候 会执行default</p>
<p>select的作用感觉非常大 因为可以想象一个场景 一个服务器上有一个服务 这个服务有个处理入口 每个请求过来我们轮训select上每个io能否进行操作 如果有那么处理这个请求 如果没有那么去到default那里返回系统繁忙请稍后操作的提示 我们可以使用select轻易实现这个需求</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/06/go多线程/" data-id="cjl22siv7000jp0o0fq5uav74" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/async/">async</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-go注意要点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/06/go注意要点/" class="article-date">
  <time datetime="2018-08-06T08:17:04.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/go注意要点/">go注意要点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h2><p>当声明一个数组的时候 但是没有声明这个数组的大小 后续是可以自己通过append来往数组里加入新的元素的(其实那个就是切片slice)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;</span><br><span class="line">	a = <span class="built_in">append</span>(a, <span class="number">12</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++&#123;</span><br><span class="line">		fmt.Println(a[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>go的结构体跟c的结构体基本一样 但是比较有意思的是 go的结构体指针调用这个结构体的元素跟这个结构体调用元素都是一样的 都是以.一点</p>
<p>例子<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">		a <span class="keyword">int</span></span><br><span class="line">		b <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	v := test&#123;<span class="number">1</span>, <span class="string">"123"</span>&#125;</span><br><span class="line">	fmt.Println(v.a)</span><br><span class="line">	fmt.Println(v.b)</span><br><span class="line">	v.a = <span class="number">6</span></span><br><span class="line">	fmt.Println(v.a)</span><br><span class="line">	<span class="keyword">var</span> structP *test = &amp;v</span><br><span class="line">	fmt.Println(structP.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>go的切片跟Python的list切片一样 都是包含开始索引 但是不包含结束索引</p>
<p>例子<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t = t[<span class="number">1</span>: <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">	fmt.Println(t[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>len()函数但会切片的长度 cap()函数返回为切片分配的空间大小<br>copy()函数可以复制一个切片</p>
<hr>
<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>之前一直被这个range弄得云里雾里 用法如下<br>for i, j := range sliceObject</p>
<p>i是下标 j是这个下标对应的元素</p>
<hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>go语言跟Java的接口不一样 go的接口定义方式就比价特别 是使用type interface两个关键字来声明的</p>
<p>接口一般都是搭配结构体来使用 一般都是一个结构体实现了这个接口的一些方法</p>
<p>例子<br>声明一个接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">	call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>声明一个结构体<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iphone <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个结构体实现这个接口的一些函数(不用全部实现都可以 go的接口并不是implement整个接口 而是implement这个接口里的一些函数)</p>
<p>实现这个接口的一个函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_iphone iphone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"this is iphone call"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	myIphone := iphone&#123;&#125;</span><br><span class="line">	myIphone.call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口中的方法理所当然是可以有返回类型的 上面那个例子是void类型的返回值 下面的例子是string类型返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">	receive() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iphone <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_iphone iphone)</span> <span class="title">receive</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"this is some call from other phone in this phone "</span> + _iphone.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="reflect反射"><a href="#reflect反射" class="headerlink" title="reflect反射"></a>reflect反射</h2><p>gp原因的反射是一种机制 可以在运行时更新变量和检查他们的值 调用他们的方法和他们支持的内在操作 而不需要在编译时就知道这些变量的具体类型</p>
<hr>
<h2 id="defer推迟"><a href="#defer推迟" class="headerlink" title="defer推迟"></a>defer推迟</h2><p>go这个defer关键字开始真的是看的我云里雾里 不知道用来干什么的 后来才知道这相当于一个延迟的”函数析构函数” 一般用来释放资源 关闭文件等等</p>
<p>而panic是在运行时捕捉到的类似数组访问月结 空指针引用等等问题 panic一般都会引起程序中断 是很严重的 所以一般都是使用error这个</p>
<p>panic引起程序中断之后 马上执行defer被延迟的函数来释放资源 以防因为程序中断而没有正确释放一些资源</p>
<hr>
<h2 id="json对象"><a href="#json对象" class="headerlink" title="json对象"></a>json对象</h2><p>讲go的结构体转为json对象的过程叫做编码 反过来叫解码</p>
<p>编码和解码分别使用下面两个函数</p>
<ul>
<li>json.Marshal</li>
<li>json.Unmarshal</li>
</ul>
<p>注意要点</p>
<ul>
<li>可以编码的结构体属性都是需要导出的 就是必须首字母是大写的</li>
<li>编码之后的结果是[]uint8类型的 需要用fmt.Printf(“%s\n”, jData)这样的方法来进行打印 否则打印出来都是数字</li>
</ul>
<p>struct tag</p>
<blockquote>
<p>结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:”value”键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/…下面其它的包也遵循这个约定。</p>
</blockquote>
<p>比如下面有个</p>
<pre><code>Login bool `json:&quot;login,omitempty&quot;`
</code></pre><p>表示当结构体中的成员为空或者零值就不生成该结构体成员</p>
<p>果然 看下面的例子 Login这个属性 我给它的struct tag设置了omitempty 而且被编码的实例这个属性是false 编码为json之后就没有这个属性 但是比较有意思的是<strong>解码之后还是会有这个属性的</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"my_name`</span></span><br><span class="line">	Login <span class="keyword">bool</span> <span class="string">`json:"login,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	u := User&#123;<span class="string">"gzm"</span>, <span class="literal">false</span>&#125;</span><br><span class="line">	jData, err := json.Marshal(u)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"convert error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(u)</span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, jData)</span><br><span class="line">	nu := User&#123;&#125;</span><br><span class="line">		err = json.Unmarshal(jData, &amp;nu)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"disonvert error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(nu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/qt2xts28f9tovml0ajf8wik0/image_1chqecnb4ur81770451lim1pvk16.png" alt="image_1chqecnb4ur81770451lim1pvk16.png-6.7kB"></p>
<p>有一个编码之后可读性很低的问题 因此可以用</p>
<pre><code>json.MarshalIndent(u, &quot;&quot;, &quot;    &quot;)
</code></pre><p>这个函数进行编码 第一个函数是结构体 第二个参数每一行输出的前缀 第三个参数是每一个级层的缩进</p>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/a754rrupb5d39br9bgk2h2eo/image_1chqecvnngqeqmlvjnh7jut21j.png" alt="image_1chqecvnngqeqmlvjnh7jut21j.png-1.9kB"></p>
<hr>
<h2 id="byte和rune"><a href="#byte和rune" class="headerlink" title="byte和rune"></a>byte和rune</h2><p>其实byte和rune其实只是unint8和int32的别称</p>
<blockquote>
<p>byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。</p>
</blockquote>
<hr>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是面向对象编程中对对象或者结构体进行参数的一种方式 避免了直接对对象或者结构体的成员进行操作</p>
<p>go的结构体的方法声明和定义比较简单 只要在一个函数中有这个结构体作为参数传入 其后声明这个方法的名字和返回值类型 没有返回值类型则返回值类型为void</p>
<p>声明一个结构体<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyUser <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Login <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>声明这个结构体的一个方法 名字为show 返回值类型为string<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u MyUser)</span> <span class="title">show</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"name "</span> + u.Name + <span class="string">" login "</span> + strconv.FormatBool(u.Login)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用这个方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	u := MyUser&#123;<span class="string">"gzm"</span>, <span class="literal">false</span>&#125;</span><br><span class="line">	fmt.Println(u.show())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/rq7jojgl1zba9emukovhesa5/image_1chrrjj84tb4ebf9vu1cng1l4d9.png" alt="image_1chrrjj84tb4ebf9vu1cng1l4d9.png-26.9kB"></p>
<p>要注意这个方法的参数列表的位置 上面那个u MyUser并不是这个参数列表 这个参数只是将结构体传进来 真正在参数列表在方法名字的后面<br><img src="http://static.zybuluo.com/gzm1997/zcgmxaml9qrt746xec11n2ep/image_1chrro3fqfiac827p1v3a1ejgm.png" alt="image_1chrro3fqfiac827p1v3a1ejgm.png-14.1kB"></p>
<p>接收器 具有方法的结构体也叫作接收器</p>
<p>一般约定一个结构体或者类具有一个指针作为接收器的方法 但是go语言很人性化 传入结构体指针的方法 一般也可以直接使用这个结构体的变量去调用这个方法 编译器会隐式地转为指针类型</p>
<hr>
<h2 id="基本文件IO"><a href="#基本文件IO" class="headerlink" title="基本文件IO"></a>基本文件IO</h2><p>一般文件的读写都是使用<strong>ioutil</strong>这个自带的库 写进去的内容和读出来的结果一般都是[]byte</p>
<p>讲byte数组写入文件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"lalla"</span></span><br><span class="line">b := []<span class="keyword">byte</span>(s)</span><br><span class="line">err := ioutil.WriteFile(<span class="string">"test.txt"</span>, b, <span class="number">0600</span>)</span><br></pre></td></tr></table></figure></p>
<p>0600的意思是文件应该按照只有当前用户可以读写的权限进行创建这个文件</p>
<p>从文件中读内容为[]byte<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rb, e := ioutil.ReadFile(<span class="string">"test.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"read file error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"file content"</span>, <span class="keyword">string</span>(rb))</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="import"><a href="#import" class="headerlink" title="import _"></a>import _</h2><p>之前这里一直想不明白为什么会有些import前面带有一个下划线的 </p>
<blockquote>
<p>import后面跟着一个_下划线意味着我们不需要import这个包的其他内容 我们只需要它执行这个包里面的init函数 所以这个下划线只是起到一个初始化的作用</p>
</blockquote>
<hr>
<h2 id="go执行方式"><a href="#go执行方式" class="headerlink" title="go执行方式"></a>go执行方式</h2><p><img src="http://static.zybuluo.com/gzm1997/qv43jeo893uwx1gqotylx4xz/image_1chuhkjdu1q171r73oem1jov1mla9.png" alt="image_1chuhkjdu1q171r73oem1jov1mla9.png-93.6kB"></p>
<ol>
<li>深度优先执行import</li>
<li>执行const</li>
<li>执行var</li>
<li>自行init函数</li>
</ol>
<p>有点出乎意料 init函数竟然是在最后执行的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/06/go注意要点/" data-id="cjl22siv5000gp0o0o6tn3jjv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mongodb入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/06/mongodb入门/" class="article-date">
  <time datetime="2018-08-06T08:16:14.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/mongodb入门/">mongodb入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看什么文档都是从基础入门开始的 不用太浮躁</p>
<p>mongodb跟sql概念上的差别<br><img src="http://static.zybuluo.com/gzm1997/f1ef1aivvlcnha9qop6ucfr0/image_1ci8lckm31isl15ai1j9tjdo1rc69.png" alt="image_1ci8lckm31isl15ai1j9tjdo1rc69.png-25.4kB"><br>mongodb是不支持表相连的</p>
<hr>
<h2 id="mongodb模式"><a href="#mongodb模式" class="headerlink" title="mongodb模式"></a>mongodb模式</h2><p>mongodb使用动态模式 开发人员可以不定义表结构 有什么列 什么类型就可以创建一个表 只要我们往表中添加了新的列或者删除了已有的列 那么行的结构就会被修改 表中的行并不需要具有相同的成员或者说列</p>
<hr>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>清屏命令</p>
<pre><code>ctrl + l
</code></pre><p>查询所有数据库</p>
<pre><code>show dbs
</code></pre><p>切换到具体一个db</p>
<pre><code>use cayley
</code></pre><p>展示所有集合</p>
<pre><code>show tables
</code></pre><p>或者</p>
<pre><code>show collections
</code></pre><p>是等价的</p>
<p>查询一个集合中所有单位document</p>
<pre><code>db.myCollection.find()
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/06/mongodb入门/" data-id="cjl22sivc000qp0o0vha96rzk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/database/">database</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mongodb/">mongodb</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dgraph图数据库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/06/dgraph图数据库/" class="article-date">
  <time datetime="2018-08-06T08:14:45.000Z" itemprop="datePublished">2018-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/dgraph图数据库/">dgraph图数据库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h2><p>dgraph的节点分为两类</p>
<ol>
<li>node节点</li>
<li>value字面量</li>
</ol>
<p>例如：</p>
<ul>
<li>a b是两个人 </li>
<li>a friend b </li>
<li>a age 12</li>
</ul>
<p>那么a b是两个节点 12是字面量 那么friend跟age都是谓语 friend指向b b是一个node age指向12 12是一个字面量 那么谓语所处的边为什么有时候指向一个node 有时候指向一个字面量呢 这就是由模式所定义的 或者说<strong>模式就是边的定义或者说模式就是谓语的定义</strong></p>
<p>1.添加模式</p>
<p>当我们项添加数据到已有的模式中 我们可以直接添加 但是我们需要添加新数据到还没有存在模式中的时候 可以有两种方式</p>
<ul>
<li>直接添加数据 让Dgraph自己找出其中的模式</li>
<li>先添加一个新的模式 然后添加数据</li>
</ul>
<p>在模式中我们需要定义索引 因为dgraph的函数跟filter过滤器都是只可以应用于添加了索引的谓语 不在模式中添加索引的话 那么各种查询进行不了</p>
<p><img src="http://static.zybuluo.com/gzm1997/fisnujzgm8a92yqmer8dy9h9/image_1ci6k5u3ir3810kr17jd1641jud40.png" alt="image_1ci6k5u3ir3810kr17jd1641jud40.png-28.8kB"></p>
<p>2.查询模式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schema(pred: [name, age, friend, owns_pet]) &#123;</span><br><span class="line">  <span class="keyword">type</span></span><br><span class="line">  index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出 很显然下面的输出都是按照谓语一个一个输出这个谓语指向的那个的类型(是node还是字面量) 以及是否具有索引 如果为false就不输出<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"data"</span>: &#123;</span><br><span class="line">    <span class="string">"schema"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"predicate"</span>: <span class="string">"age"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"int"</span>,</span><br><span class="line">        <span class="string">"index"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"predicate"</span>: <span class="string">"friend"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"uid"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"predicate"</span>: <span class="string">"name"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">        <span class="string">"index"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"predicate"</span>: <span class="string">"owns_pet"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"uid"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"extensions"</span>: &#123;</span><br><span class="line">    <span class="string">"server_latency"</span>: &#123;</span><br><span class="line">      <span class="string">"encoding_ns"</span>: <span class="number">1000000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"txn"</span>: &#123;</span><br><span class="line">      <span class="string">"start_ts"</span>: <span class="number">20</span>,</span><br><span class="line">      <span class="string">"lin_read"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="dgraph支持的数据类型"><a href="#dgraph支持的数据类型" class="headerlink" title="dgraph支持的数据类型"></a>dgraph支持的数据类型</h2><ul>
<li>int 有符号64位整数</li>
<li>float 双精度浮点数</li>
<li>string 字符串</li>
<li>bool 布尔值</li>
<li>id id是以字符串的形式进行存储的</li>
<li>dateTime 时间</li>
<li>geo 几何体</li>
</ul>
<hr>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>dgraph是使用utf-8进行编码的 一些谓语也是使用字符串来存储的 可以在加上语言标签来定义是什么语言</p>
<p>节点加上语言标签进行声明</p>
<pre><code>&quot;Amit&quot;@en
</code></pre><p>Amit这个名字是英文</p>
<p>多个语言匹配</p>
<pre><code>@lang1:...:langN
</code></pre><p>上面这个语法的特点</p>
<ul>
<li>最多只有一个结果返回</li>
<li>如果有结果出现在这个语言列表中 那么最左边那部分的匹配结果都会被返回</li>
<li>如果没有结果匹配就没有返回 但是如果最后时以<strong>.</strong>为结尾的话例外 <strong>.</strong>以为着什么语言都行 匹配上了就可以返回</li>
</ul>
<p>使用语言pipei匹配来查询一个人的朋友他的朋友名字各种语言都有<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  language_support(func: allofterms(name@hi, "अमित")) &#123;</span><br><span class="line">    name@bn:hi:en</span><br><span class="line">    age</span><br><span class="line">    friend &#123;</span><br><span class="line">      name@ko:ru:.</span><br><span class="line">      age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"data"</span>: &#123;</span><br><span class="line">    <span class="string">"language_support"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name@bn:hi:en"</span>: <span class="string">"অমিত"</span>,</span><br><span class="line">        <span class="string">"age"</span>: <span class="number">35</span>,</span><br><span class="line">        <span class="string">"friend"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name@ko:ru:."</span>: <span class="string">"Michael"</span>,</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">39</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name@ko:ru:."</span>: <span class="string">"상현"</span>,</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">24</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"name@ko:ru:."</span>: <span class="string">"Артём"</span>,</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">35</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"extensions"</span>: &#123;</span><br><span class="line">    <span class="string">"server_latency"</span>: &#123;</span><br><span class="line">      <span class="string">"encoding_ns"</span>: <span class="number">1000000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"txn"</span>: &#123;</span><br><span class="line">      <span class="string">"start_ts"</span>: <span class="number">58</span>,</span><br><span class="line">      <span class="string">"lin_read"</span>: &#123;</span><br><span class="line">        <span class="string">"ids"</span>: &#123;</span><br><span class="line">          <span class="string">"1"</span>: <span class="number">6</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="查询格式"><a href="#查询格式" class="headerlink" title="查询格式"></a>查询格式</h2><p>其实上面的查询语句一直都是有规矩可循的 但是一直没有注意到</p>
<p>之前我们说到dgraph有两种节点</p>
<ul>
<li>node节点</li>
<li>value字面量</li>
</ul>
<p>常见的两种形式<br><img src="http://static.zybuluo.com/gzm1997/rorcsu8jb8n9hrqa1znqow2z/image_1ci68dk4oo2r1gn4c3qpga18d152.png" alt="image_1ci68dk4oo2r1gn4c3qpga18d152.png-10.3kB"></p>
<p><strong>谓语不属于节点</strong></p>
<p>在查询上</p>
<ul>
<li>字面量的查询只需要把字面量的名称写入即可</li>
<li>node节点的查询需要把指向它的谓语和它的名称一起写入</li>
</ul>
<p>如下 查询Michael的字面量: name age (这些都是他指向的字面量) 以及他的朋友(他的朋友就是他指向的节点) </p>
<p><img src="http://static.zybuluo.com/gzm1997/wtcp6mmcbie8wb8zkxfut0gl/image_1ci6539gh1jp8kvq1aj9j5610hl9.png" alt="image_1ci6539gh1jp8kvq1aj9j5610hl9.png-29.5kB"></p>
<p>所以我们要进一步查询Michael的朋友的宠物 只要在上面的查询语句稍加修改即可<br><img src="http://static.zybuluo.com/gzm1997/69yxxh15cetx2ihcmlx8o71y/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180712103548.png" alt="微信图片_20180712103548.png-20.7kB"></p>
<hr>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>常见过滤器</p>
<p>1.节点上的过滤器</p>
<pre><code>allOfTerms(node_name, &quot;term1 ... termN&quot;)
</code></pre><p>节点的名字含有给出的所有单词</p>
<pre><code>anyOfTerms(node_name, &quot;term1 ... termN&quot;)
</code></pre><p>节点的名字函数给出的单词列表中的任意一个单词</p>
<p>2.边上的过滤器<br>边上的过滤器可以应用到<strong>int</strong> <strong>float</strong> <strong>string</strong> <strong>date</strong>类型的边上</p>
<ul>
<li>eq(edge_name, value) 等于</li>
<li>ge(edge_name, value) 大于等于</li>
<li>le(edge_name, value) 小于等于</li>
<li>gt(edge_name, value) 大于</li>
<li>lt(edge_name, value) 小于等于</li>
</ul>
<p><img src="http://static.zybuluo.com/gzm1997/cn452n8j541r3msayslw18j4/image_1ci698cfo30h1pi9cot8uh15ut5f.png" alt="image_1ci698cfo30h1pi9cot8uh15ut5f.png-25.5kB"></p>
<p>过滤器上可以使用逻辑<strong>AND</strong> <strong>OR</strong> <strong>NOT</strong>将过滤条件联合起来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  michael_friends_and(func: allofterms(name, "Michael")) &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">    friend @filter(ge(age, <span class="number">27</span>) AND le(age, <span class="number">48</span>)) &#123;</span><br><span class="line">      name@.</span><br><span class="line">      age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>可以使用下面两个关键字进行排序</p>
<ul>
<li>orderasc 从小到大排序</li>
<li>orderdesc 从大到小排序</li>
</ul>
<p>注意 排序只是在返回的json对象上有效果 在UI的可视化上是没效果的</p>
<p><img src="http://static.zybuluo.com/gzm1997/24e2cm0c8qdfd9236m1gs4y2/image_1ci69hu24163uvv11q8f1a0eih15s.png" alt="image_1ci69hu24163uvv11q8f1a0eih15s.png-22.3kB"></p>
<hr>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><ul>
<li>first: N 只返回前N个结果</li>
<li>offset: N 跳过前N个结果</li>
<li>after: uid 返回在这个uid后面的结果</li>
</ul>
<p><img src="http://static.zybuluo.com/gzm1997/fu3k396pmpu8hokxr3fdam20/image_1ci6a1bp71l331f50jcsd7d189f79.png" alt="image_1ci6a1bp71l331f50jcsd7d189f79.png-20kB"></p>
<hr>
<h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p>dgraph的count用起来挺方便<br><img src="http://static.zybuluo.com/gzm1997/z5upyy070wblph8bctsxo9xc/image_1ci6a8vhm1gcv1bf0sfikeh1csk7m.png" alt="image_1ci6a8vhm1gcv1bf0sfikeh1csk7m.png-13.8kB"></p>
<hr>
<h2 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h2><p>因为有时候dgraph的图非常大 那么从所有节点开始搜索是很低效的 那么根节点的概念就出现了 从根节点开始搜索</p>
<p>在根节点处 我们是使用<strong>func:</strong>和一个函数来找到一个初始化的节点集合</p>
<p>但是root节点的那个函数func是不可以接受and or not那些逻辑操作的 所以如果需要在根节点处加上这些逻辑操作需要在后面自己加一个filter过滤器</p>
<p><img src="http://static.zybuluo.com/gzm1997/ba0m0nuutqeocrps2iyi2dn3/image_1ci6e87bj1dr3lmjcotgm7aci83.png" alt="image_1ci6e87bj1dr3lmjcotgm7aci83.png-18.9kB"></p>
<hr>
<h2 id="根据谓语-边-查询"><a href="#根据谓语-边-查询" class="headerlink" title="根据谓语(边)查询"></a>根据谓语(边)查询</h2><p><img src="http://static.zybuluo.com/gzm1997/svb0a8r4coju46dtfprido4d/image_1ci6hoimm59ufol1nmu125u1snj8g.png" alt="image_1ci6hoimm59ufol1nmu125u1snj8g.png-17.2kB"></p>
<hr>
<h2 id="alias别名"><a href="#alias别名" class="headerlink" title="alias别名"></a>alias别名</h2><p>别名可以用于设置返回的json对象中key的名字 改成自己想要设置成的别名<br><img src="http://static.zybuluo.com/gzm1997/5jv13au0dcixqeoo2gv2r7z8/image_1ci6hs52rbcl10hj1s3kbd95m58t.png" alt="image_1ci6hs52rbcl10hj1s3kbd95m58t.png-20kB"></p>
<hr>
<h2 id="级联cascade指令"><a href="#级联cascade指令" class="headerlink" title="级联cascade指令"></a>级联cascade指令</h2><p>级联的概念开始真的是有点难以理解 举个例子就容易多了</p>
<p><img src="http://static.zybuluo.com/gzm1997/mhamq6mzzvrtq4ae6onrc0iw/image_1ci6iv71ofb6jfdmlp1rasfjt9.png" alt="image_1ci6iv71ofb6jfdmlp1rasfjt9.png-15.1kB"><br>上面的查询是查询Michael年纪大于等于70的朋友 Michael有年纪大于等于70的朋友就直接返回在friend的列表里 <strong>如果没有那么friend一项就直接为空</strong></p>
<p>但是加上@cascade之后效果就不一样了<br><img src="http://static.zybuluo.com/gzm1997/qixfxkm4fcuqaq6xnn24c5ww/image_1ci6j4lgv16r38pugr4ll91isl1m.png" alt="image_1ci6j4lgv16r38pugr4ll91isl1m.png-51.3kB"></p>
<p>上面加上了@cascade之后 如果Michael如果有年纪大于鞥与70的朋友那么Michael跟她的朋友一起在返回的结果里面 但是如果没有 那么连Michael也不返回</p>
<p><strong>因为级联就相当于强行的逻辑与</strong>如果后面的节点不满足要求 那么前面已经满足匹配的节点也不会被返回</p>
<hr>
<h2 id="normal指令"><a href="#normal指令" class="headerlink" title="normal指令"></a>normal指令</h2><p>@normalize指令</p>
<ul>
<li>只返回带有别名的节点</li>
<li>把结果扁平化 去除嵌套</li>
</ul>
<p><img src="http://static.zybuluo.com/gzm1997/xepaf2wqksmiq3ap5cyulypb/image_1ci6jhmbl1ptpu9k130n1ot71q5p33.png" alt="image_1ci6jhmbl1ptpu9k130n1ot71q5p33.png-52.2kB"></p>
<hr>
<h2 id="数据突变"><a href="#数据突变" class="headerlink" title="数据突变"></a>数据突变</h2><p>数据突变就是修改存储在Dgraph中的图结构<br><img src="http://static.zybuluo.com/gzm1997/h8103gfh9kvczvome1h3v7ii/image_1ci6knlvgq8l1tnb1fif1qiddev5d.png" alt="image_1ci6knlvgq8l1tnb1fif1qiddev5d.png-81.9kB"></p>
<hr>
<h2 id="External-Identifiers外部标识符"><a href="#External-Identifiers外部标识符" class="headerlink" title="External Identifiers外部标识符"></a>External Identifiers外部标识符</h2><p>Dgraph是不支持为node设置外部标记符的 所以如果开发人员希望为节点添加一个外部标记符 那么需要自己添加一条边作为外部标记符</p>
<hr>
<h2 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h2><p>这个语言标记上面已经减了很多次了 其中中文的标志使用以下来标志</p>
<pre><code>_:myID &lt;an_edge&gt; &quot;某物&quot;@zh-Hans .
</code></pre><hr>
<h2 id="反向边"><a href="#反向边" class="headerlink" title="反向边"></a>反向边</h2><p>边是有向的一个查询是不可以反向遍历的 有两种方式可以双向进行查询</p>
<ul>
<li>添加反向边到模式中 添加所有的反向边数据</li>
<li>在模式中使用@reverse关键字告诉Dgraph告诉Dgraph总是存储反向边</li>
</ul>
<pre><code>boss_of: uid @reverse .
</code></pre><hr>
<h2 id="整合已有数据"><a href="#整合已有数据" class="headerlink" title="整合已有数据"></a>整合已有数据</h2><p>当我们第一批次向数据库中导入了一系列的人物关系数据 第二批次的时候导入了一系列的公司数据 那么问题在于我们怎么把这些人物和公司关联起来呢？</p>
<p>答案肯定是添加新的模式 但是添加新的模式要注意 因为我们肯定不能在新的模式中使用下面</p>
<pre><code>_:sarah &lt;works_for&gt; _:company1 .
</code></pre><p>因为这样的话会为z这个sarah新建一个uid 而不是我们之前的那个sarah 这是一个新的sarah 正确的做法应该是</p>
<pre><code>&lt;uid-for-sarah&gt; &lt;works_for&gt; &lt;uid-for-company1&gt; .
</code></pre><p>找到sarah和company的uid根据uid定义这些已存在节点之间的新模式</p>
<p>例子<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  set &#123;</span><br><span class="line">    &lt;<span class="number">0x2</span>&gt; &lt;boss_of&gt; &lt;<span class="number">0xd</span>&gt; .</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>删除数据有三种</p>
<p>方式</p>
<ul>
<li><uid> <edge> <uid>/“value” . 根据宾语的node的uid或者宾语中的字面量的值删除一个三元组</uid></edge></uid></li>
<li><uid> <edge> * . 根据给定的一条边删除所有的三元组</edge></uid></li>
<li><uid> <em> </em> . 根据给定的一个node 删除所有的三元组</uid></li>
</ul>
<p><img src="http://static.zybuluo.com/gzm1997/qk1fftqtquhw6ef1cso2blc9/image_1ci6mejsl1l8t33ophi167a1j585q.png" alt="image_1ci6mejsl1l8t33ophi167a1j585q.png-12.4kB"></p>
<hr>
<h2 id="谓语查询"><a href="#谓语查询" class="headerlink" title="谓语查询"></a>谓语查询</h2><p>可以根据一个node节点查询这个节点所有的谓语<br>使用</p>
<pre><code>_predicate_
</code></pre><p><img src="http://static.zybuluo.com/gzm1997/szwm0v5e1sjnbdpv6j1dlxcf/image_1ci6migc0iel3o5v010j114hv67.png" alt="image_1ci6migc0iel3o5v010j114hv67.png-52.3kB"></p>
<hr>
<h2 id="拓展谓语"><a href="#拓展谓语" class="headerlink" title="拓展谓语"></a>拓展谓语</h2><pre><code>expand(_all_)
</code></pre><p>上面是查询所有的谓语 拓展谓语是根据给定的谓语进行深入查询 而不是单纯在返回结果中列出他们</p>
<p><img src="http://static.zybuluo.com/gzm1997/j5smrtslkjgzwwfgrk0p0k5a/image_1ci6mt3qg17abbh479c17cp1n1i74.png" alt="image_1ci6mt3qg17abbh479c17cp1n1i74.png-40.4kB"></p>
<hr>
<h2 id="多个查询块"><a href="#多个查询块" class="headerlink" title="多个查询块"></a>多个查询块</h2><p>没什么区别 就是多几个查询根节点而已<br><img src="http://static.zybuluo.com/gzm1997/28lixz5rfb4ty41liv8611m2/image_1ci6p35ni1idvl5j13ja12q7qdg7h.png" alt="image_1ci6p35ni1idvl5j13ja12q7qdg7h.png-26.7kB"></p>
<hr>
<h2 id="查询变量"><a href="#查询变量" class="headerlink" title="查询变量"></a>查询变量</h2><p>结果可以被存在变量里面 可以在查询的任意一个位置被使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/06/dgraph图数据库/" data-id="cjl22siv0000cp0o0c7i4eki4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dgraph/">dgraph</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM/">ORM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aiohttp/">aiohttp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/async/">async</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/backend/">backend</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/beego/">beego</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cayley/">cayley</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cookies/">cookies</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cors/">cors</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/">database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deep-web/">deep web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deploy/">deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dgraph/">dgraph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask/">flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask深入学习/">flask深入学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graph/">graph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/image/">image</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mux/">mux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/package/">package</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitMQ/">rabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/requests/">requests</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/session/">session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqlalchemy/">sqlalchemy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图数据库/">图数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图算法/">图算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件开发生命周期/">软件开发生命周期</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ORM/" style="font-size: 10px;">ORM</a> <a href="/tags/aiohttp/" style="font-size: 17.5px;">aiohttp</a> <a href="/tags/async/" style="font-size: 15px;">async</a> <a href="/tags/backend/" style="font-size: 10px;">backend</a> <a href="/tags/beego/" style="font-size: 12.5px;">beego</a> <a href="/tags/cayley/" style="font-size: 15px;">cayley</a> <a href="/tags/cookies/" style="font-size: 10px;">cookies</a> <a href="/tags/cors/" style="font-size: 10px;">cors</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/deep-web/" style="font-size: 10px;">deep web</a> <a href="/tags/deploy/" style="font-size: 10px;">deploy</a> <a href="/tags/dgraph/" style="font-size: 10px;">dgraph</a> <a href="/tags/flask/" style="font-size: 10px;">flask</a> <a href="/tags/flask深入学习/" style="font-size: 10px;">flask深入学习</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/go/" style="font-size: 20px;">go</a> <a href="/tags/graph/" style="font-size: 10px;">graph</a> <a href="/tags/image/" style="font-size: 10px;">image</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mux/" style="font-size: 10px;">mux</a> <a href="/tags/mysql/" style="font-size: 17.5px;">mysql</a> <a href="/tags/package/" style="font-size: 10px;">package</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/rabbitMQ/" style="font-size: 10px;">rabbitMQ</a> <a href="/tags/requests/" style="font-size: 10px;">requests</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/session/" style="font-size: 12.5px;">session</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/sqlalchemy/" style="font-size: 12.5px;">sqlalchemy</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/图数据库/" style="font-size: 10px;">图数据库</a> <a href="/tags/图算法/" style="font-size: 10px;">图算法</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/软件开发生命周期/" style="font-size: 10px;">软件开发生命周期</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/20/cayley原理2/">cayley原理2</a>
          </li>
        
          <li>
            <a href="/2018/08/15/cayley原理一-获取查询结果/">cayley原理一(获取查询结果)</a>
          </li>
        
          <li>
            <a href="/2018/08/09/图数据库跟传统数据库以及图算法/">图数据库跟传统数据库以及图算法</a>
          </li>
        
          <li>
            <a href="/2018/08/08/使用rabbitMQ作为缓存队列/">使用rabbitMQ作为缓存队列</a>
          </li>
        
          <li>
            <a href="/2018/08/06/mux学习/">mux学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 gzm1997<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
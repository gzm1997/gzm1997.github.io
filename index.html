<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  

  
  <title>gzm&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="gzm&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="gzm&#39;s blogs">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="gzm&#39;s blogs">
  
    <link rel="alternate" href="/atom.xml" title="gzm&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">gzm&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java基础2：树相关前哨" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/05/java基础2：树相关前哨/" class="article-date">
  <time datetime="2019-01-05T11:40:59.000Z" itemprop="datePublished">2019-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/05/java基础2：树相关前哨/">java基础2：树相关前哨</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="元素的比较"><a href="#元素的比较" class="headerlink" title="元素的比较"></a>元素的比较</h2><p>在java里面元素的对象的比较一般是通过实现comparable或者comparator这两个接口来实现的</p>
<p>比如下面一个类 实现了comparable接口 实现接口必须<strong>覆写compareTo这个方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.compare;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面的Comparable&lt;SearchResult&gt;加上了泛型限定*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchResult</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">SearchResult</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> relativeRatio;</span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    <span class="keyword">int</span> recentOrders;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SearchResult</span><span class="params">(<span class="keyword">int</span> relativeRatio, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.relativeRatio = relativeRatio;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*需要覆写compareTo方法*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(SearchResult o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.relativeRatio != o.relativeRatio) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.relativeRatio &gt; o.relativeRatio ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.count != o.count) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count &gt; o.count ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRecentOrders</span><span class="params">(<span class="keyword">int</span> recentOrders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.recentOrders =recentOrders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是comparable接口其实不如comparator好 因为当我们需求有改变的时候 如果使用前者 意味着需要修改已经提交的代码 如果我们使用后者 那么当与比较相关的需求改变的时候 我们只需要修改第三方比较器就可以了 下面就是一个后者的例子 注意comparator这个接口的实现必须<strong>覆写compare这个函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.compare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里我们实现的是比较器comparator 这样可以让我们对比较标准进行修改的时候可以不修改我们已经交付的代码SearchResult 直接按照需求修改比较器就可以了</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 我们可以看到下面的Comparator&lt;SearchResult&gt;接口也是添加了泛型限定的*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchResultComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">SearchResult</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(SearchResult o1, SearchResult o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1.relativeRatio != o2.relativeRatio) &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.relativeRatio &gt; o2.relativeRatio ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o1.recentOrders != o2.recentOrders) &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.recentOrders &gt; o2.recentOrders ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o1.count != o2.count) &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.count &gt; o2.count ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们也使用了泛型的知识 这个就不展开了</p>
<hr>
<h2 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h2><p>上面我们介绍的是比较 主要说的是comparable跟comparator这两个接口 那么跟我们这里说的相等有什么区别呢</p>
<blockquote>
<p>comparable跟comparator都是两个类的实例用来判断大小或者说按照一种规则对这些元素进行排序的 但是这里说的相等主要是判断两个对象是否相等 相等或者不想等就完事了 没有所谓的排序 这里的场景主要是在一些map或者set集合中用来判断两个对象是否是一个相同的对象 在去重方面发挥作用</p>
</blockquote>
<p>下面我们主要说一下”相等”这个概念在TreeMap跟HashMap这两个常用的Map里面有什么不同</p>
<p>首先我们了解一下TreeMap跟ConcurrentHashMap和HashMap在使用上的一些不同：</p>
<ul>
<li>TreeMap的Key是有序的 可以支持范围查找 所以在一些需要排序的场景下很好用</li>
<li>ConcurrentHashMap和HashMap在插入和删除方面上更高效 所以后面两者更常用</li>
</ul>
<p><strong>TreeMap的key排序去重并不是基于key元素覆写hashcode函数跟equal函数的 而是实现了接口comparable 覆写了compareTo函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Key o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*treeMap一般都是在key需要排序的情况下使用 这样效率很高 但是一般用的很少 因为conncurrentHashMap跟HashMap在插入和删除方面效率很高 后两者用地比较多</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">    * 但是我们要注意 TreeMap的key排序去重并不是基于key元素覆写hashcode函数跟equal函数的 而是实现了接口comparable 覆写了compareTo函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapUsage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap treeMap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Key(), <span class="string">"value one"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Key(), <span class="string">"value two"</span>);</span><br><span class="line">        System.out.println(treeMap.size());</span><br><span class="line">        TreeMap treeMap1 = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        treeMap1.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">        <span class="comment">/*map的key是有类型 即使一开始你没有显示指定类型 但是第一次添加之后key的类型就已经固定了 后面不允许添加其他类型*/</span></span><br><span class="line">        <span class="comment">/*所以下面这一句会报错*/</span></span><br><span class="line"><span class="comment">//        treeMap1.put("2", "two");</span></span><br><span class="line">        <span class="comment">/*但是下面这一句没有报错 说明value是不限定类型的*/</span></span><br><span class="line">        treeMap1.put(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(treeMap1.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么HashMap是怎样实现元素的去重的呢<br><strong>HashMap依靠hashCode函数跟equal函数来实现去重</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewKey</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面的代码输出是1 因为：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* TreeMap依靠实现comparable接口 覆写compareTo函数来实现去重</span></span><br><span class="line"><span class="comment">* HashMap依靠hashCode函数跟equal函数来实现去重</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 所以下面的代码输出是1 HashMap把两个Key都当作是相同的了*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapUsage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hashMap.put(<span class="keyword">new</span> NewKey(), <span class="string">"value one"</span>);</span><br><span class="line">        hashMap.put(<span class="keyword">new</span> NewKey(), <span class="string">"value two"</span>);</span><br><span class="line">        System.out.println(hashMap.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="fast-fail和fast-save机制"><a href="#fast-fail和fast-save机制" class="headerlink" title="fast-fail和fast-save机制"></a>fast-fail和fast-save机制</h2><p>fast-fail机制</p>
<blockquote>
<p>fast-fail机制是一种对集合遍历操作时的错误检测机制 在遍历途中出现意料之外的修改时 通过uncheck异常暴力反馈出来</p>
</blockquote>
<p>这种机制通常出现在多线程环境下 当前线程会维护一个计数比较器 即expectedModCount 记录修改的次数 在遍历之前 会把实时修改modCount赋值给expectedModCount如果两个数据不想等就会抛出异常</p>
<p>这里我之前看源代码就有发现 具体见<a href="https://gzm1997.github.io/2018/12/24/ArrayList%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">ArrayList相关</a><br><img src="http://static.zybuluo.com/gzm1997/md2hhpl0ar2275h0zjfsl6nf/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190105192702.png" alt="微信图片_20190105192702.png-46.7kB"></p>
<p>我们知道ArrayList就是fast-fail的 那么我们有哪些常见的是fast-save的呢 下面要介绍CopyOnWriteArrayList用来代替ArrayList 该容器会对内部的迭代器进行加锁操作</p>
<p>顺便我们这里介绍一下COW奶牛家族 就是copy on write的意思<br><strong>它是并发的一种新思路 实行读写分离</strong></p>
<ul>
<li>写操作就复制一个新的集合 在新集合上添加或者删除 等到修改结束 将原集合的引用指向新的集合</li>
<li>读和遍历操作 不需要加锁 直接读</li>
</ul>
<p>但是在使用cow的时候需要注意</p>
<ol>
<li>尽量设置合理的初始容量 这跟ArrayList那些是一样的 因为扩容代价太大</li>
<li>使用批量添加或者修改 避免频繁复制整个集合 消耗内存</li>
</ol>
<p>下面是一个简单例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面我们使用了COW家族的一员 就是copy on write机制</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这个机制适合使用在读多写极少的高并发场景下</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 因为他的原理就是：实行读写分离 如果是写操作 则复制一个新集合 在新集合中添加和删除元素 待一切修改完成之后 再将原集合的引用指向新的集合 这样做的好处就是可以高并发地对COW进行读和遍历操作 而不需要加锁 因为当前集合不会添加任何元素</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用注意要点：</span></span><br><span class="line"><span class="comment">* 1. 尽量设置合理的容量初始值 因为会设置扩容的问题</span></span><br><span class="line"><span class="comment">* 2. 使用批量添加或删除的方法 因为每一次修改都是需要copy出一份新的集合出来的 如果分开修改 那么代价很大</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 有点和缺点：</span></span><br><span class="line"><span class="comment">* 优点：是线程安全的</span></span><br><span class="line"><span class="comment">* 缺点：不能读取到最新的数据*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Long&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Long&gt;();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(System.nanoTime());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"cost time "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/05/java基础2：树相关前哨/" data-id="cjqjgi46b000tqko0q4ywybrp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ArrayList相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/24/ArrayList相关/" class="article-date">
  <time datetime="2018-12-24T07:44:34.000Z" itemprop="datePublished">2018-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/24/ArrayList相关/">ArrayList相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>集合框架有很多可以直接使用的集合 比如常用的就有ArrayList跟HashMap 这篇文章主要研究一下ArrayList</p>
<hr>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>声明并且初始化一个arraylist<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList.add(<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">2</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/*获取list的大小*/</span></span><br><span class="line">System.out.println(<span class="string">"size of ArrayList is "</span> + arrayList.size());</span><br></pre></td></tr></table></figure></p>
<p>注意</p>
<pre><code>ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();
</code></pre><p>尖括号里面只可以是类比如Integer 而不可以是基本数据类型比如int那些</p>
<p>我们先来看看arraylist中有哪些字段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的初始化容量是10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被空实例用的空数组实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被那些默认容量 但是目前还是空的实例用的数组实例</span></span><br><span class="line"><span class="comment"> * 跟上面那个EMPTY_ELEMENTDATA不一样的地方是 这个当第一个元素被添加的时候他知道什么时候开始扩张容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这就是真正存储着arraylist的元素的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示数组的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>接下来我们看一下</p>
<pre><code>arrayList.add(1);
</code></pre><p>中发生了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面很明显是先确定容量是否足够 然后使用下标定位到数组中元素到最后 把新的元素添加上去 那么我们看一下<strong>ensureCapacityInternal</strong>函数是怎样确定容量是否足够 以及怎么扩张容量的 这个函数最终是使用<strong>grow</strong>函数进行扩容的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们很显而易见地知道 每一次扩张容量都是在原来容量的基础上增加一半</p>
<pre><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
</code></pre><p>从上面我们可以知道ArrayList的空间都是不够就动态增加的 主要使用<strong>Arrays.copyOf</strong>这个函数重新分配空间 那么就会有一个问题 如果一开始我们无参构造ArrayList的时候 没有指定容量 那么默认容量就是10 如果这时候我们要add大量的元素 比如1000个 那么就需要多次动态扩容 这样会造成<strong>被动扩容和数组复制的额外开销</strong></p>
<p>所以 <strong>使用ArrayList之前指定恰当的容量 那么是可以避免上面的额外开销 但是如果容量没有指定恰当 有可能会造成内存溢出</strong></p>
<hr>
<h2 id="遍历问题"><a href="#遍历问题" class="headerlink" title="遍历问题"></a>遍历问题</h2><p>我看别人的博客 说ArryList一般有三种遍历方式</p>
<ul>
<li>下标遍历</li>
<li>for循环遍历</li>
<li>迭代器遍历</li>
</ul>
<hr>
<p>下标遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下标遍历 这是最快的一种方式*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">    <span class="comment">/*使用下标定位数组元素的时候 只可以使用get函数定位*/</span></span><br><span class="line">    System.out.println(arrayList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显而易见 这是最快的一种遍历方式 没什么好说的</p>
<p>for循环遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*for循环遍历*/</span></span><br><span class="line"><span class="keyword">for</span> (Integer integer : arrayList) &#123;</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法效率介于中间 但是因为无法看到这个方法的源代码 所以无从分析</p>
<p>迭代器遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用迭代器进行遍历*/</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = arrayList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是效率最低的一种方法 我们可以看一下他的源代码分析一下</p>
<pre><code>arrayList.iterator();
</code></pre><p>这里返回一个内置类的实例 这个内之类实现了<strong>Iterator<e></e></strong>接口 我们可以看一下这个内置类的一些字段比较有意思</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line"><span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure>
<p>前面两个变量顾名思义 看注释也可以知道他们是干什么的 后面两个<br><strong>expectedModCount</strong>表示预期的数组被修改的次数 <strong>modCount</strong>是实际上被修改的次数 这两个字段有什么用呢？</p>
<p>首先我们来看一个问题</p>
<blockquote>
<p>ArrayList是非线性安全的 就是有可能同时被多个线程操作的话 出现数据不一致性 所以ArrayList必须一个时间内只可以给一个单独的线程操作</p>
</blockquote>
<p>但是如果在遍历的时候 如何防止我在遍历一个ArrayList的时候 避免这个arraylist同时被其他线程修改呢</p>
<p>迭代器遍历这种方法就可以做到这种效果 因为迭代器的hasNext函数跟Next函数都可以使用<strong>checkForComodification</strong>函数来检查是否在遍历的时候被其他线程修改了 怎么检查？ 靠的就是上面两个字段<strong>expectedModCount</strong> <strong>modCount</strong> 具体如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>所以了 我们可以看得出 上面三种遍历ArrayList的方式 从效率来看肯定是<br>下标定位 &gt; for循环 &gt; 迭代器</p>
<p>但是如果涉及线程安全的时候 又恰巧这时候使用的ArrayList(虽然在线程安全的时候不推荐使用ArrayList) 我们就可以使用迭代器遍历的方法遍历ArrayList</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/24/ArrayList相关/" data-id="cjqjgi4590000qko0dzkt1kxh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-暑假学习总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/03/暑假学习总结/" class="article-date">
  <time datetime="2018-12-03T07:00:45.000Z" itemprop="datePublished">2018-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/03/暑假学习总结/">暑假学习总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>郭柱明</p>
<hr>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>因为我之前都要使用博客记录的习惯 所以下面很多链接都链接向我自己写的博客上的 所以导致下面看起来内容不多 其实下面内容还是有的</p>
<hr>
<h2 id="阶段一：图数据库考察"><a href="#阶段一：图数据库考察" class="headerlink" title="阶段一：图数据库考察"></a>阶段一：图数据库考察</h2><p>图数据库的考察是我进入公司开始做的第一部分工作 我们考察图数据库的历程大概是下面这样的<br><img src="http://static.zybuluo.com/gzm1997/3wnxcz6pvlj4utj87qfu5cy0/image_1crgtnkj772g3l31ouj1o8tbchm.png" alt="image_1crgtnkj772g3l31ouj1o8tbchm.png-8.2kB"></p>
<ol>
<li>neo4j是由鸿波进行考差 neo4j是很完善的图数据库 但是只有他的企业版是支持集群的 但是收费 所以pass 考察的细节都在洪波那里 那时候我还没来 所以细节不清楚</li>
<li>dgraph是我考察 细节在如下<a href="https://www.zybuluo.com/gzm1997/note/1210656" target="_blank" rel="noopener">我的博客记录</a> <a href="https://docs.dgraph.io/get-started/#installing-on-windows" target="_blank" rel="noopener">官方文档</a>也可以学习 <a href="https://tour.dgraph.io/intro/1/" target="_blank" rel="noopener">推荐教程</a>这个是学习dgraph最好的一个方法了 dgraph也是一个成熟的图数据库 有以下特点<ol>
<li>支持resetful api</li>
<li>使用graphql+-查询语言进行查询</li>
<li>有多种语言的client</li>
<li>但是不支持自由选择底层存储 就是我们公司的高可用mongo集群的作用发挥不出来</li>
</ol>
</li>
<li>cayley是我们重点考察的图数据库 花了很多功夫 这是<a href="https://www.zybuluo.com/gzm1997/note/1209189" target="_blank" rel="noopener">我对于cayley的基础知识总结</a> 这是我后来对cayley做的一次<a href="http://ksogit.kingsoft.net/wpsyun/relation-graph/blob/gzm/doc/cayley.pdf" target="_blank" rel="noopener">技术分享PPT</a><ul>
<li>对于cayley的原理跟设计思想我有去思考的 探索出来的细节未必正确 但是思想我觉得还是可取的<ul>
<li><a href="https://www.zybuluo.com/gzm1997/note/1251054" target="_blank" rel="noopener">cayley原理1</a></li>
<li><a href="https://www.zybuluo.com/gzm1997/note/1254154" target="_blank" rel="noopener">cayley原理2</a></li>
</ul>
</li>
<li>研究了cayley整个项目的构建方法 然后<strong>修复了cayley在持久层测试方面上的一个bug 为cayley贡献了一点代码</strong> git commit<a href="https://github.com/cayleygraph/cayley/commit/6da908eaad0216479791aa58806b66672ab7c18f" target="_blank" rel="noopener">在这里</a> 其实这个问题包含的思想很重要的 扬哥因此还送了我一平红酒 细节请看<a href="https://www.zybuluo.com/gzm1997/note/1336191" target="_blank" rel="noopener">docker在测试中的应用</a> 后来我也用docker在开发和测试中写了另外一些demo 用法不一样<a href="#%E4%BD%BF%E7%94%A8docker%E4%B8%BA%E6%B5%8B%E8%AF%95%E6%8F%90%E4%BE%9B%E4%B8%80%E6%AC%A1%E6%80%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93">基于容器的开发和测试</a></li>
</ul>
</li>
</ol>
<hr>
<h2 id="阶段二：开发"><a href="#阶段二：开发" class="headerlink" title="阶段二：开发"></a>阶段二：开发</h2><hr>
<h3 id="cayley时期"><a href="#cayley时期" class="headerlink" title="cayley时期"></a>cayley时期</h3><p>我们做了一个demo 就是基于我们的cayley图数据库来构建我们的关系图谱 从而找出用户中的最近联系的人以及可能认识的人 当时因为在设计理念以及对cayley的使用上 我跟扬哥跟莹姐之间存在分歧 所以当时每个人都按照自己的想法来写了一个自己的版本 我的版本如下<br><a href="http://ksogit.kingsoft.net/wpsyun/relation-graph/tree/gzm/graphRelation" target="_blank" rel="noopener">graphRelation</a><br>里面还算有不少注释</p>
<hr>
<h3 id="hugegraph时期"><a href="#hugegraph时期" class="headerlink" title="hugegraph时期"></a>hugegraph时期</h3><p>hugegraph说实话我们没接触多长时间 所以在这一阶段写的代码并不多 有一个需求就是找子图 代码在<a href="http://ksogit.kingsoft.net/wpsyun/relation-graph/tree/gzm/subgraph" target="_blank" rel="noopener">subgraph</a> 里面我也写了部分注释 </p>
<p>博客详情在<a href="https://www.zybuluo.com/gzm1997/note/1333099" target="_blank" rel="noopener">我的subgraph博客</a></p>
<p>hugegraph时期我花了很多时间在看<a href="http://tinkerpop.apache.org/docs/3.1.7-SNAPSHOT/reference/#traversal" target="_blank" rel="noopener">gremlin官方文档</a>上 因为gremlin语法众多而且复杂 我并没有像以前翻译cayley的查询语言Gizmo那样用博客把常用查询语法记录下来 所以有点可惜 但是太多了记下来也没用 可以当官方文档是字典 使用的时候去查阅 平时只需要记住常用的查询语法即可</p>
<hr>
<h2 id="使用docker为测试提供一次性的数据库"><a href="#使用docker为测试提供一次性的数据库" class="headerlink" title="使用docker为测试提供一次性的数据库"></a>使用docker为测试提供一次性的数据库</h2><p>docker容器目前有三个用处</p>
<ul>
<li>提供一次性的环境</li>
<li>提供弹性的云服务</li>
<li>组件微服务架构</li>
</ul>
<p>我有做基于容器docker的开发和测试上一些简单的尝试 详情请看下面<a href="http://ksogit.kingsoft.net/wpsyun/relation-graph/tree/gzm/severInDocker" target="_blank" rel="noopener">基于容器开发</a></p>
<p>cayley在它的单元测试跟集成测试部分就是用了docker 但是这里docker的使用跟上面有所不一样 上面是所有的部分都包含在容器内部 但是cayley的思路很特别也很有借鉴意义</p>
<p><strong>cayley因为支持很多种数据库作为底层存储 所以他在每一次的单元测试以及集成测试过程中 都使用docker生成一个数据库容器 并将程序在运行过程中产生的持久层数据都放进这个数据库容器中 这样当测试结束 清除这个容器 保证了测试都进行在一个一次性的环境中 不留下任何测试数据</strong></p>
<p>我为cayley修好的这个bug就是上面这个问题里面一个bug 虽然这个bug没什么太大意义 但是cayley在这里的设计思路确实非常值得我们借鉴 <strong>借助docker为我们的单元测试集成测试提供一次性的数据库容器</strong></p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/03/暑假学习总结/" data-id="cjqjgi4780020qko0i5a4pxtk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图数据库/">图数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/图谱/">图谱</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-subgraph概况" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/03/subgraph概况/" class="article-date">
  <time datetime="2018-12-03T06:57:02.000Z" itemprop="datePublished">2018-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/03/subgraph概况/">subgraph概况</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为我们现在使用的图数据库都有一个瓶颈就是<strong>不支持图数据库集群</strong> 在图数据库的使用上我们只可以使用单点 如果使用多点 那么就会有很多缓存不一致等问题 因为现在开源的图数据库d很多都是企业内部图数据库的阉割版 都是不支持图数据库层面的集群的 所以不可以做上线版本的 那么<strong>离线分析</strong>可以作为一个方向</p>
<hr>
<h2 id="离线数据"><a href="#离线数据" class="headerlink" title="离线数据"></a>离线数据</h2><p><img src="http://static.zybuluo.com/gzm1997/174wxmwfn5iwgon89z0g1oys/image_1crhbqje41b356it1sb361o1ujo9.png" alt="image_1crhbqje41b356it1sb361o1ujo9.png-20.9kB"></p>
<p> 都是csv格式的文件 文件中每一行的格式都很单一 就是</p>
<pre><code>userid,fileid
</code></pre><p>例如</p>
<pre><code>311915299,10437872764
</code></pre><p>每一条数据意味着某个用户id读了某个文件id</p>
<p>而且这些数据所有都是fileid具有约束条件<strong>pv&lt;6</strong>的 这次离线分析的思想很简单就是： 物以类聚 人以群分 想通过以fileid为中心形成很多子图 而且pv&lt;6使得这些文件都不是属于烂大街的文件和具有普适性的 比如文档教程之类 过于烂大街的文件形成的子图对于我们来说没有什么价值 因为它们无法为我们的用户画像带来帮助 那么这些文件的属性大概率可以表明这些子图中用户的身份 比如以简历为中心的子图中的用户大概率是应届毕业生之类的 思路是很简单的</p>
<hr>
<h2 id="schema和graph"><a href="#schema和graph" class="headerlink" title="schema和graph"></a>schema和graph</h2><p>所有的代码都在<a href="http://ksogit.kingsoft.net/wpsyun/relation-graph/tree/gzm/subgraph" target="_blank" rel="noopener">subgraph</a><br>构建子图部分如下：<br><img src="http://static.zybuluo.com/gzm1997/ecow1zzi4x0corwax41snnhd/image_1crhd07pqg6ldu7sqo1bp8kna1m.png" alt="image_1crhd07pqg6ldu7sqo1bp8kna1m.png-31.4kB"></p>
<p>构建图的思路很简单<br><img src="http://static.zybuluo.com/gzm1997/xx9i7j0h8hv26eq73ruegid6/image_1crhdmvi8s2bgfohrl1h3cgg23.png" alt="image_1crhdmvi8s2bgfohrl1h3cgg23.png-23.3kB"><br>在hugegraph里面上面的创建其实是分为两部分的</p>
<ol>
<li>schema </li>
<li>graph</li>
</ol>
<p>对应上面图中<br><img src="http://static.zybuluo.com/gzm1997/qteo7bofu3rkhjxy27m191lt/image_1crhe6s8c1khm16t61hcmmtj1ldj40.png" alt="image_1crhe6s8c1khm16t61hcmmtj1ldj40.png-32.2kB"></p>
<p>分别对应项目中如下两部分<br><img src="http://static.zybuluo.com/gzm1997/s3v79cx1e034kd5s7nbrlld5/image_1crhebmsdu8cpbk1dsiboj17la4t.png" alt="image_1crhebmsdu8cpbk1dsiboj17la4t.png-62.5kB"></p>
<p>这里有必要说一下我代码里面一些单元测试 单元测试在我的代码里面很重要 在这里我基本是写一个函数就对应写一个单元测试 这样你看我的代码 看我的单元测试就知道这些函数是怎样使用的了 所以<strong>看我的代码 看我的单元测试是关键</strong></p>
<p>代码中schema文件夹下schema.go就是用来构建schema中propertyKey vertexLabel edgeLabel中的函数 在schema_test.go中可以看到这些对应函数的使用方法 同时也有部分注释<br>代码中schema文件夹跟上面类似</p>
<hr>
<h2 id="读取csv数据构造图"><a href="#读取csv数据构造图" class="headerlink" title="读取csv数据构造图"></a>读取csv数据构造图</h2><p>入口在如下main函数<br><img src="http://static.zybuluo.com/gzm1997/r6x6wei7uv0qbl56agcte8yv/image_1crjbgkh718351l79195c13r1f179.png" alt="image_1crjbgkh718351l79195c13r1f179.png-49.3kB"></p>
<p><a href="http://ksogit.kingsoft.net/wpsyun/relation-graph/blob/gzm/subgraph/construct/constructWholeGraph.go#L17" target="_blank" rel="noopener">ConstructGraph函数</a>每一次读取一个csv文件 迭代处理每一行 对于每一行</p>
<pre><code>userid, fileid
</code></pre><p>先生成一个user的点和一个file的点 以及生成一条从user指向file类型为connect的边 一直重复上述操作 直至数据被处理完</p>
<p>上述的操作有两点要注意的地方：</p>
<ol>
<li>我是单线程同步构造图的 但是73哥csv耗时上并不是太长 可以接受</li>
<li>如果对构造图有耗时上的要求 那么推荐使用无gremlin的纯graph api(restful api)</li>
</ol>
<hr>
<h2 id="查询子图"><a href="#查询子图" class="headerlink" title="查询子图"></a>查询子图</h2><p><img src="http://static.zybuluo.com/gzm1997/ig8vj46wz3ix43vddv8c0uqh/image_1crjblvqejc1hqpham11ebm5q1m.png" alt="image_1crjblvqejc1hqpham11ebm5q1m.png-39.5kB"><br>查询的函数和单元测试都写在上面的红色部分内 入口在下面的绿色部分内</p>
<p>查询就是使用gremlin api发送gremlin语句过去 这里真的是一句gremlin用到烂 主要用的一句gremlin就是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SubGraphGremlin = <span class="string">"sg = g.V().hasLabel('file').has('fileid','%s').repeat(bothE().subgraph('sg').otherV().simplePath()).until(bothE().count().is(0)).cap('sg').next();sg = sg.traversal();r=sg.V().choose(hasLabel('user'), count(), values('fileid'));r"</span></span><br></pre></td></tr></table></figure>
<p>我们在hugegraph上进行查询大多数情况都是<strong>在gremlin上做文章</strong> 对于gremlin的语法我们需要很注意 所以这里是说一下上面这段gremlin是什么意思</p>
<p>可以分为四部分</p>
<p>1.</p>
<pre><code>sg = g.V().hasLabel(&apos;file&apos;).has(&apos;fileid&apos;,&apos;%s&apos;).repeat(bothE().subgraph(&apos;sg&apos;).otherV().simplePath()).until(bothE().count().is(0)).cap(&apos;sg&apos;).next();
</code></pre><p>g是一个全局Traversal(全局遍历器) 理论上使用这个全局遍历器awo我们可以首先定位到图里面的某个点或者某部分点 并且以这些点作为我们迭代查询的始点 要注意g其实是这个全局遍历器的别名 在代码里面使用gremlin api post发送gremlin语句的时候需要加上这个别名 否则无法识别g是什么 比如我在在子图的代码里是这样写的<br><img src="http://static.zybuluo.com/gzm1997/0a9wnz322pst3cravx8nl5sx/image_1crjckhir1sio1ec91dvn3sri9n2j.png" alt="image_1crjckhir1sio1ec91dvn3sri9n2j.png-39.9kB"></p>
<p>详细解释如下<br><img src="http://static.zybuluo.com/gzm1997/ph2r9d85ys31axb7zy354ee5/image_1crjdr1gcbdk1sen1r2el5knd30.png" alt="image_1crjdr1gcbdk1sen1r2el5knd30.png-65.8kB"></p>
<p>2.</p>
<pre><code>sg = sg.traversal();
</code></pre><p>对上一个步骤获取的子图sg 获取这个子图的一个遍历器</p>
<p>3.</p>
<pre><code>r=sg.V().choose(hasLabel(&apos;user&apos;), count(), values(&apos;fileid&apos;));
</code></pre><p>通过这个遍历器 通过choose语句 choose语句相当于if else逻辑 满足第一个参数条件 则执行第二个参数 否则执行第三个参数</p>
<p>所以上面的意思是如果子图里面的点是有user的label的话 那么返回这些点的数量(子图中用户数量) 否则(就是file的点) 返回浙西file的fileid属性 并且将上诉结果都放到一个r变量中</p>
<p>4.</p>
<pre><code>r
</code></pre><p>返回查询结果</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/03/subgraph概况/" data-id="cjqjgi46u001kqko09y63fe1k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gremlin/">gremlin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hugegraph/">hugegraph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/subgraph/">subgraph</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-docker在测试中的作用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/03/docker在测试中的作用/" class="article-date">
  <time datetime="2018-12-03T06:54:52.000Z" itemprop="datePublished">2018-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/03/docker在测试中的作用/">docker在测试中的作用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>郭柱明</p>
<hr>
<h2 id="cayley与docker"><a href="#cayley与docker" class="headerlink" title="cayley与docker"></a>cayley与docker</h2><p>cayley是一个用go语言编写的很规范的图数据库 他的设计方式很值得我们学习 这篇文章我们简单聊一聊docker在cayley这个图数据库中的应用</p>
<p>docker主要在cayley中有两处使用</p>
<ul>
<li>将整个cayley作为一个应用打包为一个docker镜像</li>
<li>在每一个涉及持久层操作的单元测试和集成测试中 使用docker生成一个一次性数据库供数据存储</li>
</ul>
<p>第一点很常见 就是使用dockerfile的方式将应用打包成镜像 这样我们可以通过docker很简单地安装和运行cayley<br><img src="http://static.zybuluo.com/gzm1997/jac2d2yvc3wbw3zf5b167836/image_1crovr4t31hmc14814cdg3qmtd9.png" alt="image_1crovr4t31hmc14814cdg3qmtd9.png-172.6kB"><br>但是第二点真的很少见 cayley在第二点上算是非常创新的做法 现在主要讨论第二点</p>
<hr>
<h2 id="docker在测试中的使用"><a href="#docker在测试中的使用" class="headerlink" title="docker在测试中的使用"></a>docker在测试中的使用</h2><p>docker的使用情景有很多种 我们可以看一下阮一峰博客上说的<br><img src="http://static.zybuluo.com/gzm1997/q1ab5aqsk234npm1uutkiixw/image_1crp006g81526bpjoll1t61kk3m.png" alt="image_1crp006g81526bpjoll1t61kk3m.png-24.8kB"></p>
<blockquote>
<p>cayley在这里正是第一种情况 使用docker提供一次性环境 </p>
</blockquote>
<blockquote>
<p>因为cayley是支持多种数据库作为底层存储 如果在开发测试过程 对每一种数据都进行本地安装 本地系统环境等因素一定会让操作很麻烦 所以cayley选择在各种测试进行的时候使用docker镜像生成一个需要的数据库容器 并且将这个容器运行起来 返回这个容器运行在的IP地址和端口 这样就可以提供给测试的代码进行连接 注意整个测试并不是发生在容器内部的 仅仅是数据库在容器内部</p>
</blockquote>
<blockquote>
<p>当我们操作完需要的持久层操作之后 就可以彻底删除这个容器 也不会导致测试的数据遗留</p>
</blockquote>
<p>如果现在不熟悉docker的基本使用 可以先看一下阮一峰<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">这篇博客</a>先了解简单的docker helloworld</p>
<hr>
<p>cayley使用一个封装了docker remote api的第三方包go docker client生成一个数据库容器的步骤如下<br><img src="http://static.zybuluo.com/gzm1997/vmx01k3i53shmw9bscxj3bwa/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180910223243.png" alt="生成一个数据库容器"></p>
<p>注意 cayley是原本缺失第二步pullimage的 所以导致原来运行cayley所有的测试都会导致设计持久层的测试被skip 正就是我帮cayley修复那个bug 扬哥因此送了我一瓶红酒 commit详情在<a href="https://github.com/cayleygraph/cayley/commit/6da908eaad0216479791aa58806b66672ab7c18f" target="_blank" rel="noopener">pull image from remote repository if there is not image at local machine</a> 这是我人生第一次给比较大的开源项目贡献代码。。</p>
<p>下面是我看了cayley的代码后 整理的一个hello world 生成一个可用的mongo的容器 运行 并且返回mongo的IP地址和端口进行连接 因为下面我已经写了尽可能多的注释了 所以不一一解释了<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/fsouza/go-dockerclient"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置</span></span><br><span class="line"><span class="keyword">type</span> fullConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//主要是镜像的配置</span></span><br><span class="line">	docker.Config</span><br><span class="line">	<span class="comment">//主要是容器的配置</span></span><br><span class="line">	docker.HostConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测IP地址和端口是否可用 可连接</span></span><br><span class="line"><span class="keyword">const</span> wait = time.Second * <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitPort</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	c, err := net.DialTimeout(<span class="string">"tcp"</span>, addr, wait)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Close()</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> dt := time.Since(start); dt &lt; wait &#123;</span><br><span class="line">		time.Sleep(wait - dt)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机选择可用的端口</span></span><br><span class="line"><span class="keyword">const</span> localhost = <span class="string">"127.0.0.1"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randPort</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		min = <span class="number">10000</span></span><br><span class="line">		max = <span class="number">30000</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		port := min + rand.Intn(max-min)</span><br><span class="line">		c, err := net.DialTimeout(<span class="string">"tcp"</span>, fmt.Sprintf(<span class="string">"%s:%d"</span>, localhost, port), time.Second)</span><br><span class="line">		<span class="keyword">if</span> c != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.Close()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> check for a specific error</span></span><br><span class="line">			<span class="keyword">return</span> port</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//一般通过以下sock文件初始化docker client</span></span><br><span class="line">	Address := <span class="string">`unix:///var/run/docker.sock`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化镜像和容器的配置</span></span><br><span class="line">	<span class="keyword">var</span> conf docker.Config</span><br><span class="line">	port := <span class="string">"27017"</span></span><br><span class="line">	<span class="comment">//镜像的名字叫mongo</span></span><br><span class="line">	conf.Image = <span class="string">"mongo"</span></span><br><span class="line">	conf.OpenStdin = <span class="literal">true</span></span><br><span class="line">	conf.Tty = <span class="literal">true</span></span><br><span class="line">	<span class="comment">//容器暴露出27017这个端口</span></span><br><span class="line">	conf.ExposedPorts = <span class="keyword">map</span>[docker.Port]<span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">		<span class="string">"27017/tcp"</span>: &#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fconf := fullConfig&#123;</span><br><span class="line">		Config: conf,</span><br><span class="line">		HostConfig: docker.HostConfig&#123;</span><br><span class="line">			<span class="comment">//端口映射 容器的27017端口映射到本地的27017端口</span></span><br><span class="line">			PortBindings: <span class="keyword">map</span>[docker.Port][]docker.PortBinding&#123;</span><br><span class="line">				<span class="string">"27017/tcp"</span>: &#123;</span><br><span class="line">					&#123;</span><br><span class="line">						HostIP:   <span class="string">"0.0.0.0"</span>,</span><br><span class="line">						HostPort: port,</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在linux系统下 可以原生地运行docker 但是在其他系统下需要特殊处理 随机选择可用的端口进行映射</span></span><br><span class="line">	<span class="keyword">if</span> runtime.GOOS != <span class="string">"linux"</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"this is not linux"</span>)</span><br><span class="line">		lport := strconv.Itoa(randPort())</span><br><span class="line">		<span class="comment">// nothing except Linux runs Docker natively,</span></span><br><span class="line">		<span class="comment">// so we randomize the port and expose it on Docker VM</span></span><br><span class="line">		fconf.PortBindings = <span class="keyword">map</span>[docker.Port][]docker.PortBinding&#123;</span><br><span class="line">			docker.Port(port + <span class="string">"/tcp"</span>): &#123;&#123;</span><br><span class="line">				HostIP:   localhost,</span><br><span class="line">				HostPort: lport,</span><br><span class="line">			&#125;&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		port = lport</span><br><span class="line">		log.Println(<span class="string">"this is not linux env, change the port to"</span>, lport)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化docker client</span></span><br><span class="line">	cli, err := docker.NewClient(Address)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从远程拉取指定的docker镜像 如果本地已经存在指定镜像 那么操作被跳过</span></span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> err := cli.PullImage(docker.PullImageOptions&#123;</span><br><span class="line">		<span class="comment">//通过 镜像所在组/镜像名称:镜像标签 来指定特定的镜像</span></span><br><span class="line">		Repository:   <span class="string">"docker.io/mongo:latest"</span>,</span><br><span class="line">		<span class="comment">//指定输出位置</span></span><br><span class="line">		OutputStream: &amp;buf,</span><br><span class="line">	&#125;, docker.AuthConfiguration&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"pull 容器失败"</span>)</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">"buf"</span>, buf.String())</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从上面的镜像中生成一个docker容器</span></span><br><span class="line">	cont, err := cli.CreateContainer(docker.CreateContainerOptions&#123;</span><br><span class="line">		Config: &amp;fconf.Config,</span><br><span class="line">		HostConfig: &amp;fconf.HostConfig,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"创建容器失败"</span>)</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//生成一个强制移除容器的关闭函数</span></span><br><span class="line">	closer := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		cli.RemoveContainer(docker.RemoveContainerOptions&#123;</span><br><span class="line">			ID: cont.ID,</span><br><span class="line">			Force: <span class="literal">true</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> closer()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//启动容器</span></span><br><span class="line">	<span class="keyword">if</span> err := cli.StartContainer(cont.ID, &amp;fconf.HostConfig); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"启动容器失败"</span>)</span><br><span class="line">		closer()</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听容器是否启动成功</span></span><br><span class="line">	info, err := cli.InspectContainer(cont.ID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"监视容器失败"</span>)</span><br><span class="line">		closer()</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取容器运行在的IP地址和端口 这里默认使用的是 bridge的网络模式</span></span><br><span class="line">	addr := info.NetworkSettings.IPAddress</span><br><span class="line">	addr += <span class="string">":"</span> + port</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在10机会监听数据库的连接url是否可用</span></span><br><span class="line">	ok := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span> &amp;&amp; !ok; i++ &#123;</span><br><span class="line">		ok = waitPort(addr)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		log.Println(<span class="string">"一直连接失败"</span>)</span><br><span class="line">		closer()</span><br><span class="line">		log.Fatal(<span class="string">"tcp connect fail"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"addr"</span>, addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>cayley将上面的常用操作都封装成函数在<a href="https://github.com/cayleygraph/cayley/blob/master/internal/dock/dock.go" target="_blank" rel="noopener">docker操作</a> 这些使用docker生成一次性数据库并使用的一个例子可见<a href="https://github.com/cayleygraph/cayley/blob/master/graph/nosql/mongo/mongo_test.go" target="_blank" rel="noopener">mongo_test</a></p>
<p><strong>cayley在这一点上做的很精彩 也很创新 非常值得我们学习</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/03/docker在测试中的作用/" data-id="cjqjgi45x000eqko0zarusfk2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cayley/">cayley</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/">docker</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java基础：入职华为前的重启" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/03/java基础：入职华为前的重启/" class="article-date">
  <time datetime="2018-12-03T06:41:45.000Z" itemprop="datePublished">2018-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/03/java基础：入职华为前的重启/">java基础：入职华为前的重启</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前我学java都是看看菜鸟教程就算了 那时候急功近利 而且因为用的少 每次学完都无一例外会忘记得一干二净 但是明年去华为肯定是需要使用java了 所以现在重新认真学习和使用java 下面是一些基础知识 比较浅显</p>
<p>因为每个小的知识点 我都是会在自己的示例代码里写很多注释 所以就不拓展来讲了</p>
<hr>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.parameters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 看了书本才知道 原来java的先可以分为：</span></span><br><span class="line"><span class="comment"> * 1.基本数据类型</span></span><br><span class="line"><span class="comment"> * 2.引用变量 引用变量就是相当于指针了</span></span><br><span class="line"><span class="comment"> * 基本数据类型作为函数参数传入是无法被修改的 引用变量作为函数参数传入可以</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 除此之外 根据可是否可以被修改 也可以分为两种类型：</span></span><br><span class="line"><span class="comment"> * 1.immutable不可修改 比如int跟string</span></span><br><span class="line"><span class="comment"> * 2.mutable可修改 比如 StringBuilder</span></span><br><span class="line"><span class="comment"> * 两种，不可修改就是当这个类型的参数传入函数中之后 函数中的任何操作都对这个参数不产生实质上的作用*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">immutable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"old"</span>);</span><br><span class="line">        change(str, str);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        String string = <span class="keyword">new</span> String(<span class="string">"lala"</span>);</span><br><span class="line">        changeStr(string);</span><br><span class="line">        System.out.println(<span class="string">"after changestr "</span> + string);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">        changeInt(num);</span><br><span class="line">        System.out.println(<span class="string">"after changeInt "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试修改StringBuilder的函数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * StringBuilder传进来本身是引用变量 是可以被修改的 穿进去之后又因为他本身是mutable的 所以被修改成功*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuilder str0, StringBuilder str1)</span> </span>&#123;</span><br><span class="line">        str0.append(<span class="string">"append0"</span>);</span><br><span class="line">        str1.append(<span class="string">"append1"</span>);</span><br><span class="line"></span><br><span class="line">        str0 = <span class="keyword">new</span> StringBuilder(<span class="string">"new string builder"</span>);</span><br><span class="line">        str0.append(<span class="string">"new append"</span>);</span><br><span class="line">        System.out.println(<span class="string">"inside func "</span> + str0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试修改string的函数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * String传进来的引用变量 所以一开始是可以被修改的 但是因为String是immutable的 所以即使引用变量穿进去之后最后也是修改失败*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeStr</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        string类型的参数 修改效果都是修改了参数的局部变量</span></span><br><span class="line">        str = <span class="string">"change str "</span>;</span><br><span class="line">        System.out.println(<span class="string">"str inside func "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试修改int类型的函数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * int这里是作为基本数据类型传进去的 所以本身就不可以被修改 无论是传进去之后是mutable还是immutable的*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeInt</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int类型的参数 修改效果都是修改了参数的局部变量</span></span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">"inside func"</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/d8m9r4s94r0v3m1dqpc6bq6o/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181203142538.png" alt="微信图片_20181203142538.png-20.1kB"></p>
<hr>
<h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.staticBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 我们静态static变量都是被共享的 在类初始化的时候执行 具有很高的优先级 想想被其他共享 肯定是需要最早进行执行或者初始化的</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* static&#123;...&#125;这样的就是静态代码块 也是跟静态变量一样*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*所有的静态代码块的优先级都是很高的 在类初始化执行*/</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"这是父类的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是父类的构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*所有的静态代码块的优先级都是很高的 在类初始化执行*/</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子类的静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子类的构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*静态方法中不能使用可以被修改的对象 否则会出现线程安全问题*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestStaticFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticBlock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">/*静态代码块因为是共享的 所以只被执行一次 在上面那条语句中已经被执行了 所以下面的new语句中不会被执行了*/</span></span><br><span class="line">        <span class="keyword">new</span> Son();</span><br><span class="line">        Son.TestStaticFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/1y22ix7efgio78sgh35aruje/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181203142854.png" alt="微信图片_20181203142854.png-14.6kB"></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.staticBlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String prior = <span class="string">"done"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*根据输出结果来看 static无论是静态变量还是静态代码块(除了静态方法)</span></span><br><span class="line"><span class="comment">    * 都是按照先后顺序来执行的 比如下面的静态变量先进行初始化 再执行下面的静态代码块*/</span></span><br><span class="line">    <span class="keyword">static</span> String last = f() ? g() : prior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是f函数"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是g函数"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"lala"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"这是静态代码块"</span>);</span><br><span class="line">        System.out.println(last);</span><br><span class="line">        g();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/krrsrlfgzts594szohncxd7j/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181203143006.png" alt="微信图片_20181203143006.png-10.3kB"></p>
<hr>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.overload;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*方法的重载只允许参数不一样 其他：</span></span><br><span class="line"><span class="comment">* 1.访问控制符</span></span><br><span class="line"><span class="comment">* 2.方法名称</span></span><br><span class="line"><span class="comment">* 都必须一模一样</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 总而言之 重载就是参数不一样而已 只能是参数不一样！！！！！！！*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overloadTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是测试函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overloadTest</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是重载的函数内部 传进来的参数为"</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverloadMethods overloadMethods = <span class="keyword">new</span> OverloadMethods();</span><br><span class="line">        overloadMethods.overloadTest();</span><br><span class="line">        overloadMethods.overloadTest(<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/xtkejzk5bvz19z1n6f1pddp3/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181203143326.png" alt="微信图片_20181203143326.png-12.3kB"></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.overload;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方法重载的注意要点已经写在OverloadMethods这个类里面 这里记录一下重载方法匹配的优先级</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 匹配优先级：</span></span><br><span class="line"><span class="comment">* 1.精确匹配</span></span><br><span class="line"><span class="comment">* 2.如果是基本数据类型 自动转化为更大表示范围的基本类型</span></span><br><span class="line"><span class="comment">* 3.通过自动拆箱与撞线</span></span><br><span class="line"><span class="comment">* 4.同过子类向上转向继承路线一次匹配 就是子类优先的意思</span></span><br><span class="line"><span class="comment">* 5.通过可变参数匹配 可变参数匹配时最低等级的</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 要注意子类的方法也是可以重载父类的方法的*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OverloadMethod</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"参数为int的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OverloadMethod</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"参数为Integer的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Priority priority = <span class="keyword">new</span> Priority();</span><br><span class="line">        priority.OverloadMethod(<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/onhyhx1ntyojd6idtyotn0xe/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181203143405.png" alt="微信图片_20181203143405.png-7.7kB"></p>
<hr>
<h2 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.override;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是父类函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子类覆写的四大要求：</span></span><br><span class="line"><span class="comment">* 1. 子类方法中的访问权限不得小于父类中的</span></span><br><span class="line"><span class="comment">* 2. 子类方法的返回类型必须可以向上转型为父类的返回类型</span></span><br><span class="line"><span class="comment">* 3. 子类方法的异常类型必须可以向上转型为父类的异常类型</span></span><br><span class="line"><span class="comment">* 4. 子类方法的方法签名 参数类型以及个数必须完全一样*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*覆写只可以针对：</span></span><br><span class="line"><span class="comment">* 1. 非静态</span></span><br><span class="line"><span class="comment">* 2. 非final</span></span><br><span class="line"><span class="comment">* 3. 非构造方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 其实不可以覆写静态方法很容易理解 因为静态方法是属于类的 如果子类覆写了父类的静态方法 那么久存在两个名称相同的静态方法 两个都可以能被调用*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子类覆写的函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Son();</span><br><span class="line">        father.DoSomething();</span><br><span class="line">        <span class="comment">/*像下面这样向下转型是不可以的*/</span></span><br><span class="line"><span class="comment">//        Son son = new Father();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/8m6mxnimsot5e1j205wkvj57/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181203145213.png" alt="微信图片_20181203145213.png-7.7kB"></p>
<hr>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.template;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meat</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Meat"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Soup"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用泛型的好处：</span></span><br><span class="line"><span class="comment">* 1. 避免使用重载写多种方法</span></span><br><span class="line"><span class="comment">* 2. 类型擦除 避免强制转换带来的风险</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 什么是类型擦除:</span></span><br><span class="line"><span class="comment">* 所有的泛型参数都相当于转换为Object类型 进去是什么 出来就是什么 避免了类型强制转换带来的风险*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*任何在尖括号中的指代一种未知类型 即使放String在尖括号里面 这时候的String也不再是jav.lang.String不一样了*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stove</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*尖括号必须位于：</span></span><br><span class="line"><span class="comment">    1.类名之后 或者</span></span><br><span class="line"><span class="comment">    2.方法返回类型之前*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">heat</span><span class="params">(T food)</span> </span>&#123;</span><br><span class="line">        System.out.println(food + <span class="string">" is done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Meat meat = <span class="keyword">new</span> Meat();</span><br><span class="line">        Soup soup = <span class="keyword">new</span> Soup();</span><br><span class="line">        Stove.heat(meat);</span><br><span class="line">        Stove.heat(soup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/9muxneag9y1fq6rbwetxzop8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181203143644.png" alt="微信图片_20181203143644.png-9.8kB"></p>
<hr>
<h2 id="包装数据类型的缓存"><a href="#包装数据类型的缓存" class="headerlink" title="包装数据类型的缓存"></a>包装数据类型的缓存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.boxing;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*除了float和double之外 其他包装数据类型都会使用缓存 六个包装类直接赋值的时候 就是调用对应包装类的静态工厂valueOf*/</span></span><br><span class="line"><span class="comment">/*    public static Integer valueOf(int i) &#123;</span></span><br><span class="line"><span class="comment">        如果存在缓存区间里面 就用缓存的</span></span><br><span class="line"><span class="comment">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span></span><br><span class="line"><span class="comment">            return IntegerCache.cache[i + (-IntegerCache.low)];</span></span><br><span class="line"><span class="comment">        如果没有就重新创建一个新的</span></span><br><span class="line"><span class="comment">        return new Integer(i);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*直接重新创建一个对象 分配内存空间*/</span></span><br><span class="line">        Integer integer = <span class="keyword">new</span> Integer(<span class="number">11</span>);</span><br><span class="line">        System.out.println(<span class="string">"新创建的Integer类型"</span> + integer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*先查询缓存区是否存在这个值 如果存在就是用缓存中的实例 如果没有就重新new一个*/</span></span><br><span class="line">        Integer integer1 = Integer.valueOf(<span class="number">11</span>);</span><br><span class="line">        System.out.println(<span class="string">"新建的Integer类型"</span> + integer1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><img src="http://static.zybuluo.com/gzm1997/iq5qkpwjk4xgffsmuhsva5kc/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181203143821.png" alt="微信图片_20181203143821.png-10.1kB"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/03/java基础：入职华为前的重启/" data-id="cjqjgi46d000wqko0jkc3gx0o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基于容器的开发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/11/基于容器的开发/" class="article-date">
  <time datetime="2018-09-11T01:19:46.000Z" itemprop="datePublished">2018-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/11/基于容器的开发/">基于容器的开发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>郭柱明</p>
<hr>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>虚拟化技术在服务端开发中越来越常用 docker就是常用的一种虚拟化技术 docker的虚拟化并不是系统级别的虚拟化 而是进程级别的虚拟化 他把一个进程相关的代码文件 环境变量 第三方包等等相关都打包进一个”容器”之中 可以</p>
<ul>
<li>实现对运行环境版本控制</li>
<li>提供一次性地测试环境</li>
<li>动态扩容或者缩容</li>
<li>有利于实现微服务架构</li>
</ul>
<hr>
<h2 id="一种基于容器的开发模式"><a href="#一种基于容器的开发模式" class="headerlink" title="一种基于容器的开发模式"></a>一种基于容器的开发模式</h2><p>花了一个多星期时间 暂时是为了实现以下开发的一种设计模式<br><img src="http://static.zybuluo.com/gzm1997/00eldqhzofxgr8zaicfl2cmd/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180910212550.png" alt="微信图片_20180910212550.png-55.1kB"><br>在开发环境 我们只需要按照系统的功能将系统划分为多个模块 分别将这些模块打包为docker镜像 然后推送至远程仓库 </p>
<p>在部署和测试环境 只需要安装了go语言 docker 以及封装了docker remote api的go第三方包go docker client 在这边只需要运行我们预先写好的启动文件(这个稍后会详细介绍) 从远程仓库中拉取我们需要的每个小模块的镜像 分别生成容器 运行各个容器 各个容器之间相互协同工作 我们<strong>在部署测试这边 我们不需要关注每个容器内部是如何工作的 我们只需要关注在顶层如何调度这些子模块进行协同工作</strong></p>
<hr>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我现在做的一个demo其实非常简单 就是以mongo为数据库 以beego为框架 写一个简单的用户注册登录页面 登陆之后才有权限浏览一个特殊的页面<br><a href="http://ksogit.kingsoft.net/s_guozhuming/severInDocker" target="_blank" rel="noopener">gitlab地址</a></p>
<ol>
<li>注册一个新的用户 将用户的名字 id 密码存进mongo的一个表</li>
<li>登录的时候使用名字和密码进行登录 使用session跟踪用户 session实现方式为借用cookie</li>
<li>如果登录成功自动跳转到一个display页面 如果没有登录那么提醒用户需要登录</li>
</ol>
<p>基本逻辑功能实现非常简单了 所以不多说</p>
<p>然后是测试上 在</p>
<ul>
<li>注册</li>
<li>登录</li>
<li>display页面</li>
</ul>
<p>三个小模块上 都编写了单元测试<br><a href="http://ksogit.kingsoft.net/s_guozhuming/severInDocker/blob/master/tests/signup_test.go" target="_blank" rel="noopener">注册测试</a> <a href="http://ksogit.kingsoft.net/s_guozhuming/severInDocker/blob/master/tests/login_test.go" target="_blank" rel="noopener">登录测试</a> <a href="http://ksogit.kingsoft.net/s_guozhuming/severInDocker/blob/master/tests/display_test.go" target="_blank" rel="noopener">display页面测试(需要登录权限)</a><br>以及对上诉各个小模块串联起来测试的集成测试<a href="http://ksogit.kingsoft.net/s_guozhuming/severInDocker/blob/master/web_test.go#L16-72" target="_blank" rel="noopener">集成测试</a></p>
<p>煞费苦心写单元测试和集成测试的原因有 我们可以在容器运行的时候让容器自动运行所有的单元测试和集成测试 所有测试都是在容器中进行的 可以借机利用容器可以为我们的测试提供一次性环境的优点来运行测试 试想一下：我们每次在自动化部署项目到服务器之后 肯定是希望我们的单元测试和集成测试都可以自动跑一次 来来检验 这是很方便的 更何况如果是使用容器来运行这些测试 那么测试完成之后 容器被删除 测试过程在持久层产生的数据也会被删除干净 不对整个服务造成其他干扰</p>
<hr>
<h2 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h2><p>根据我们上面的设计 我们可以将整个demo划分为两个模块 一个mongo 一个写好的beego server</p>
<p>mongo已经有人将它打包为镜像 并且推送至远程仓库dockerhub上去了 所以我们可以直接使用 不需要自己打包 那么我们只需要打包上面写好的beego server</p>
<p>docker镜像的打包方式有三种</p>
<ul>
<li>Dockerfile配置文件</li>
<li>docker remote api</li>
<li>封装了docker remote api的第三方包</li>
</ul>
<p>开发过程中打包镜像推荐使用<strong>第一种方式</strong> 不推荐使用第二第三种方式 第二第三中方式适合拉取已经构造好的远程镜像到本地生成容器来运行</p>
<p>我们来看一下我们的beego server的Dockerfile配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.10.3</span><br><span class="line">COPY . /go/src/hello</span><br><span class="line">WORKDIR /go/src/hello</span><br><span class="line">RUN go get github.com/astaxie/beego</span><br><span class="line">RUN go get github.com/smartystreets/goconvey</span><br><span class="line">RUN go get gopkg.in/mgo.v2</span><br><span class="line">RUN go build</span><br><span class="line">RUN tr -d &quot;\r&quot; &lt; run.sh &gt; run.sh</span><br><span class="line">RUN chmod -R 777 run.sh</span><br><span class="line">EXPOSE 8080</span><br><span class="line">EXPOSE 27017</span><br><span class="line">CMD sh run.sh</span><br></pre></td></tr></table></figure></p>
<p>Dockerfile一些详细的使用可以大家可以看一下旭升之前写的docker入门 这里我只简单说一下我这里的dockerfile的大概含义</p>
<pre><code>FROM golang:1.10.3
</code></pre><p>基于golang作为基础镜像来构造我们的镜像</p>
<pre><code>COPY . /go/src/hello
</code></pre><p>将我们这个demo的除了<strong>.dockerignore</strong>上标记的文件都拷贝到go镜像的<strong>/go/src/hello</strong>文件夹下</p>
<pre><code>WORKDIR /go/src/hello
</code></pre><p>工作路径为<strong>/go/src/hello</strong></p>
<pre><code>RUN go get github.com/astaxie/beego
RUN go get github.com/smartystreets/goconvey
RUN go get gopkg.in/mgo.v2
RUN go build
</code></pre><p>下载需要的go第三方包 并对demo进行编译 生成了demo名字相同的hello可执行文件</p>
<pre><code>RUN tr -d &quot;\r&quot; &lt; run.sh &gt; run.sh
</code></pre><p>因为一个Dockerfile文件中只可以有一个CMD命令 我们既需要运行测试文件 又需要运行服务 那么我们只可以将运行服务和测试都写进一个sh脚本里面 然后在dockfile中只需要运行这个sh脚本就可以了 上面的命令只是为了去除脚本的”\r” 使得sh文件中可以cd ..</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">./hello &amp;</span><br><span class="line">cd tests &amp;&amp; go test -v &amp;&amp; cd ..</span><br><span class="line">go test -v -tags integration</span><br><span class="line">wait</span><br></pre></td></tr></table></figure>
<p>正如上面所说 run.sh这个脚本做的内容有</p>
<ul>
<li>运行之前编译生成的可执行文件</li>
<li>进入tests文件夹 执行所有的单元测试</li>
<li>从tests文件夹出来 执行集成测试</li>
</ul>
<p>我们可以在dockerfile文件所在的根目录下使用</p>
<pre><code>docker image build -t 镜像名字:标签名字 .
</code></pre><p>命令来生成打包好的镜像</p>
<p>至此 我们要做的beego server镜像打包好了 <strong>我们的镜像根据Dockerfile上所配置的而言：这个镜像被下载到本地 生成容器 之后运行 这个容器会自动运行我们的server服务 并且自动执行所有的单元测试和集成测试</strong></p>
<p>使用</p>
<pre><code>docker push 镜像名字:标签名字
</code></pre><p>将这个镜像推送至你的远程dockerhub仓库里面(实现需要进行docker login进行登录)</p>
<p>那么 我们已经完成了一半的工作量 如下<br><img src="http://static.zybuluo.com/gzm1997/gko9avqzyu1i28joqdh4s96n/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180910221816.png" alt="微信图片_20180910221816.png-30.6kB"></p>
<hr>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>我们剩下来的一半工作就是编写拉取远程仓库中的镜像到本地 生成相应的容器 协调各个容器之间的工作 使得整个服务运行起来</p>
<p>上面说到 在使用docker的方式中我们有三种</p>
<ol>
<li>Dockerfile</li>
<li>docker remote api</li>
<li>封装了remote api的第三包</li>
</ol>
<p>在拉取镜像这部分 我们是推荐使用第三种方式的 因为设想一下 如果使用这种方式 我们在部署测试的时候只需要那边的环境安装了go和docker以及封装了remote api的第三包 那么需要起这个服务只需要简单de地运行我们写好的这个go启动脚本 那么当给让测试的同学来起我们的服务的时候 他们甚至不需要懂得docker的命令 只需要知道怎么运行go文件就可以了</p>
<p>完整的启动文件<a href="http://ksogit.kingsoft.net/s_guozhuming/severInDocker/blob/master/startUp.go" target="_blank" rel="noopener">startUp.go</a><br>对于每一个子模块或者说每一个镜像 我们都需要经历下面的过程 才可以将这个子模块在本地的一个docker容器中进行运行<br><img src="http://static.zybuluo.com/gzm1997/vmx01k3i53shmw9bscxj3bwa/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180910223243.png" alt="微信图片_20180910223243.png-9.7kB"></p>
<ol>
<li>构造Config和HostConfig等等 会定义与镜像和容器相关的配置 Config一般包含基本信息 名字内存等等 HostConfig一般是与ip和端口等相关</li>
<li>PullImage下载远程镜像到本地</li>
<li>CreateContainer根据镜像和上诉的配置构造容器</li>
<li>StartContainer启动容器</li>
<li>InspectContainer监视容器</li>
</ol>
<hr>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>我们可以来看一下 当我们的环境中只安装了go和docker以及封装了go docker client这个第三方包的时候 运行我们的启动文件startUp.go将整个服务启动起来<br><img src="http://static.zybuluo.com/gzm1997/3aac0hodckcvfbo8xkg02t6o/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180910223809.png" alt="微信图片_20180910223809.png-53.5kB"></p>
<p>注意上诉运行的本质就是</p>
<ol>
<li>拉取mongo远程镜像到本地</li>
<li>生成一个mongo容器进行运行 返回容器所在的IP地址和端口以备beego server连接mongo数据库</li>
<li>拉取我们之前打包好的beego server镜像到本地</li>
<li>生成beego server容器 并且将mongo容器运行返回的IP地址和端口作为环境变量传进beego server容器中以供连接数据库</li>
<li>beego server容器运行之后自动运行所有单元测试和集成测试(这部分已经打包在Dockerfile中了成为镜像本身的一部分)</li>
</ol>
<p>我们可以看一下这两个容器的运行情况<br><img src="http://static.zybuluo.com/gzm1997/fq1q35zwsy3ggh7436wl3e5s/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180910224321.png" alt="微信图片_20180910224321.png-25.5kB"></p>
<p>在查看一下 我们的beego server容器中自动运行单元测试集成测试的结果输出 需要在docker logs命令中指定容器的名字<br><img src="http://static.zybuluo.com/gzm1997/60juaky6upa44p3fq1h3asmg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180910224438.png" alt="微信图片_20180910224438.png-54.7kB"></p>
<hr>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>说了这些可能会觉得莫名其妙 为什么要这样做呢 其实喔自己觉得这都是为了<strong>微服务架构</strong>做准备</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/11/基于容器的开发/" data-id="cjqjgi474001wqko0gru2uwem" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/">docker</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-goroutine与工作池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/22/goroutine与工作池/" class="article-date">
  <time datetime="2018-08-22T11:38:11.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/22/goroutine与工作池/">goroutine与工作池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/gzm1997/workerPool" target="_blank" rel="noopener">github地址</a></p>
<hr>
<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>我们在使用go的时候 特别是面对并发的情况下 经常需要使用多线程 goroutine可以用来解决这个问题 一个goroutine解决一个线程的问题 但是我们要知道一个系统的<strong>最大线程数</strong>是有限的 大到这个限制 那么线程数量就不会增加了 更重要的是 线程太多的时候 CPU需要在线程之间频繁地切换 切换过于频繁也会导致CPU的<strong>使用率</strong>下降的 所以我们是有必要限制在这种情况下的<strong>线程数量</strong></p>
<hr>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>网上的一个方案就是设置工作池或者说线程池 我们从工作队列中获取工作之后只可以从这个工作池中获取一个可用的线程 然后执行工作 工作池中我们其实存的是并不是线程 而是用来传输工作的管道 我们通过限制在工作池中的管道的数量 从工作队列中获取的工作只可以被从工作池中获取出来的一条管道传输到另一边 然后在那边就行处理 这样就可以限制了线程的数量(以上思路和下面图片皆来自CSDN博主)</p>
<p><img src="http://static.zybuluo.com/gzm1997/rl41bhe4usmqigg88e7qqy5x/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180822185246.png" alt="微信图片_20180822185246.png-34.8kB"></p>
<p>那么有个问题是怎么限制上面所说的工作池中任务管道的数量呢？<br>其实我们可以将<strong>工作池本身就定义为一个管道</strong> 然后将限定数量的工作管道传输进这个工作池大管道中 然后所有的任务从任务队列中取出之后 都需要从工作池大管道中获取一个工作管道 然后通过这个工作管道将工作传输过去 让那边完成这个工作 完成工作之后再将这个工作管道发送回工作池管道 等待下一次被取出</p>
<hr>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>顶一个Task接口 里面有个完成这个工作的方法DoTask 所以的任务都需要实现这接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">interface</span> &#123;</span><br><span class="line">	DoTask() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体定义了一种任务的结构体 实现了Task这个接口<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ItTask <span class="keyword">struct</span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t ItTask)</span> <span class="title">DoTask</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"a task is finished"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要定义一个传输工作的管道类型</p>
<pre><code>// 用来传输任务的管道
type TaskChan chan Task
</code></pre><p>像上面所说 我们把工作池也设计为一个管道</p>
<pre><code>// 用来传输 传输任务的管道(就是上面那个) 的管道
type PoolChan chan TaskChan
</code></pre><p>然后我们需要两个全局变量</p>
<ul>
<li>缓存我们所有有待完成的工作的一个管道</li>
<li>工作池大管道</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	AllTaskQueue TaskChan</span><br><span class="line">	TaskPool PoolChan</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	AllTaskQueue = <span class="built_in">make</span>(TaskChan)</span><br><span class="line">	TaskPool = <span class="built_in">make</span>(PoolChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面开始我忘记了再init函数中对这两个公有变量进行初始化了 导致后面一开始使用这两个管道发送和接受信息一致没反应 但是也不报错 很坑爹 我觉得是因为公有变量如果没有被初始化 是不可以用来传输信息的 但是这种情况是不会报错的</p>
<p>然后我们需要将上面用来传输进一步封装 其实不封装也可以 主要是给给我们这个传输任务的管道加一个quit管道 以应道需要中途中断我们的任务</p>
<pre><code>type Worker struct {
    Todo TaskChan
    quit chan bool
}
</code></pre><p>给Worker定义一个启动函数 这个函数将我们这个任务管道Todo发送给工作池管道TaskPool 然后等待这个工作管道中发送来新的工作任务 完成这个任务 并且重新将这个任务管道发送回工作池管道中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			TaskPool &lt;- w.Todo</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> task := &lt;-w.Todo:</span><br><span class="line">				<span class="keyword">if</span> err := task.DoTask(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Println(<span class="string">"task fail"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> &lt;-w.quit:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产生一个新的worker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">()</span> *<span class="title">Worker</span></span> &#123;</span><br><span class="line">	w := &amp;Worker&#123;&#125;</span><br><span class="line">	w.Todo = <span class="built_in">make</span>(TaskChan)</span><br><span class="line">	w.quit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外我们还需要顶一个分发器<br>分发器中含有两个重要字段 一个数可用的worker指针数组(其实相当于是任务管道数组) 另一个也是一个quit管道 用来接收暂停的信号</p>
<pre><code>type Dispatcher struct {
    AvailableWorkers []*Worker
    Quit chan bool
}
</code></pre><p>同时我们也需要声明一个分发器运行函数 这个函数首先需要声明限定数量的worker 然后将这些worker中的任务管道发送到公有变量 那个工作池管道中 然后每个worker中的任务管道等到传送过来的消息 并且进行处理</p>
<p>第二部分需要做的就是监听任务队列AllTaskQueue这个管道看看有没有新的任务被发送过来 一旦检测到 从工作池管道中获取一个任务管道 并且将这个任务从这个工作管道中传输过去</p>
<p>main函数中要做的事情就很简单了 一个就是运行一个分发器 一个是多线程地制造多个任务 然后阻塞地等待任务呗接受和完成<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dis := pool.Dispatcher&#123;&#125;</span><br><span class="line">	forever := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		dis.Run()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			t := pool.ItTask&#123;&#125;</span><br><span class="line">			pool.AllTaskQueue &lt;- t</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;- forever</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果<br><img src="http://static.zybuluo.com/gzm1997/82n1peoq3l5hd7h0oghzf3wi/image_1clgm6h5upf4qto1d8ovfiuue15.png" alt="image_1clgm6h5upf4qto1d8ovfiuue15.png-23.9kB"></p>
<p>完整的源代码可以看我<a href="https://github.com/gzm1997/workerPool" target="_blank" rel="noopener">github地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/22/goroutine与工作池/" data-id="cjqjgi467000nqko0sbobye95" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cayley原理2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/20/cayley原理2/" class="article-date">
  <time datetime="2018-08-20T09:25:00.000Z" itemprop="datePublished">2018-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/20/cayley原理2/">cayley原理2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="cayley查询过程"><a href="#cayley查询过程" class="headerlink" title="cayley查询过程"></a>cayley查询过程</h2><p>cayley的查询过程相当复杂 下面是我个人的学习结果 仅仅是个人看法 无法保证绝对正确<br><img src="http://static.zybuluo.com/gzm1997/no1a9uh8euf17s9v1hm9k9ou/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180820172126.png" alt="微信图片_20180820172126.png-16.9kB"></p>
<hr>
<h2 id="构造态射数组"><a href="#构造态射数组" class="headerlink" title="构造态射数组"></a>构造态射数组</h2><p>在cayley中的查询一般我们都是构造一个path结构体实例 例如查询从A出发 经过节点12 可以达到什么节点</p>
<pre><code>p := cayley.StartPath(store, quad.String(&quot;A&quot;)).Out(quad.Int(12))
</code></pre><p>上面的语句实质上返回一个path实例 就是p 对于我们用来查询的结构path<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Path <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack       []morphism</span><br><span class="line">	qs          graph.QuadStore <span class="comment">// Optionally. A nil qs is equivalent to a morphism.</span></span><br><span class="line">	baseContext pathContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面有一个重要的字段</p>
<pre><code>stack       []morphism
</code></pre><p><strong>morphism态射</strong>在范畴论中就是一个函数变换的抽象过程 cayley中的态射我们可以理解是我们每一个out int has等等指向下一个节点迭代的函数封装 我们每一个指向下一个的迭代(in out等)都转换为一个morphism态射 然后存在path中的stack<strong>态射数组</strong></p>
<blockquote>
<p>这个stack存储着表示我们查询的每一个划分(out in has等等)的态射</p>
</blockquote>
<p>每一个态射在cayley中的定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> morphism <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsTag    <span class="keyword">bool</span></span><br><span class="line">	Reversal <span class="function"><span class="keyword">func</span><span class="params">(*pathContext)</span> <span class="params">(morphism, *pathContext)</span></span></span><br><span class="line"><span class="function">	<span class="title">Apply</span>    <span class="title">applyMorphism</span></span></span><br><span class="line"><span class="function">	<span class="title">tags</span>     []<span class="title">string</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>其中Reversal返回的态射是一个反向的态射(比如out的反向态射就是in) 这就是cayley实现无向图的原因 每个态射都包含一个它的反向态射</li>
<li>Apply为执行这个态射的具体函数 这个函数返回值中得到的shape中就表示了执行态射后得到的节点</li>
</ul>
<p>举一个简答的例子 也是上面那个例子</p>
<pre><code>p := cayley.StartPath(store, quad.String(&quot;A&quot;)).Out(quad.Int(12))
</code></pre><p>上面这条查询语句在声明了一个path结构体的同时 也构造出我们上面所说的<strong>态射数组</strong><br>下面的绿色大框即为我们的态射数组stack 两个蓝色框即为我们数组中的两个态射 都是morphism结构体 但是我们可以看红色框框 他们的apply这个函数是不一样的 一个是isMorphism 一个outMorphism</p>
<p><img src="http://static.zybuluo.com/gzm1997/76y9vn6l45cx30d3w747rpy2/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180820155549.png" alt="微信图片_20180820155549.png-45.6kB"></p>
<p>我们可以很容易理解为什么有outMorphism态射 但是不能理解为什么有isMorphism这个态射 其实isMorphism是初始化的态射</p>
<hr>
<h2 id="构造shape"><a href="#构造shape" class="headerlink" title="构造shape"></a>构造shape</h2><p>shape顾名思义就是我们查询路径的一种表现形式 表示了我们使用path查询始末的一条抽象路径 如上面的查询抽象的一个shape就是</p>
<pre><code>A -&gt; 12 -&gt;
</code></pre><p>shape在cayley中只是一个接口 但凡实现了这个接口中的方法的结构体都是shape 具体的形式非常多样和复杂 我们这里不做详细研究 shape接口定义如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shape represent a query tree shape.</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// BuildIterator constructs an iterator tree from a given shapes and binds it to QuadStore.</span></span><br><span class="line">	BuildIterator(qs graph.QuadStore) graph.Iterator</span><br><span class="line">	<span class="comment">// Optimize runs an optimization pass over a query shape.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It returns a bool that indicates if shape was replaced and should always return a copy of shape in this case.</span></span><br><span class="line">	<span class="comment">// In case no optimizations were made, it returns the same unmodified shape.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If Optimizer is specified, it will be used instead of default optimizations.</span></span><br><span class="line">	Optimize(r Optimizer) (Shape, <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个具体的shape的例子 可见shape的具体类型和机构是很多样的 没必要具体研究<br><img src="http://static.zybuluo.com/gzm1997/bamzi6zpilvq6sha5khhxro8/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180820162647.png" alt="微信图片_20180820162647.png-31.5kB"></p>
<p>可以看到下面 随着态射一个一个被执行 我们的到的构造出来的shape也是变化的 每一次态射之后的到的shape都作为参数传入下一个被执行的态射函数 shape不断积累 不断拓张 最终形成我们需要的查询路径<br><img src="http://static.zybuluo.com/gzm1997/2x1c3zt37b32j3u8st294mu5/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180820162145.png" alt="微信图片_20180820162145.png-17.3kB"></p>
<p>构造shape部分还包含了大量的shape优化 这部分复杂而内容很多 这里不展开</p>
<hr>
<h2 id="构造迭代器和迭代链"><a href="#构造迭代器和迭代链" class="headerlink" title="构造迭代器和迭代链"></a>构造迭代器和迭代链</h2><p><strong>Iterator迭代器</strong>这个概念我们可以理解只负责某一部分计算工作的组件 cayley的查询设计是由若干个迭代器<strong>嵌套</strong>或者<strong>依次排列</strong>组合成的 呈现一个<strong>分布式结构</strong> 组合成的最终迭代器叫做<strong>IterateChain迭代器链</strong> 跟上面的shape一样 迭代的种类也是多种多样的 在这个分布式结构中的迭代器种类也不是都是类型一样的 所以宏观上我们不必关系具体使用了何种迭代器</p>
<p>cayley中对于迭代器的声明也是一个接口 在cayley中但凡实现了这个接口中所有方法的结构体我们都统称为迭代器Iterator</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">	Tagger() *Tagger</span><br><span class="line">	TagResults(<span class="keyword">map</span>[<span class="keyword">string</span>]Value)</span><br><span class="line">	Result() Value</span><br><span class="line">	Next(ctx context.Context) <span class="keyword">bool</span></span><br><span class="line">	NextPath(ctx context.Context) <span class="keyword">bool</span></span><br><span class="line">	Contains(ctx context.Context, v Value) <span class="keyword">bool</span></span><br><span class="line">	Err() error</span><br><span class="line">	Reset()</span><br><span class="line">	Clone() Iterator</span><br><span class="line">	Stats() IteratorStats</span><br><span class="line">	Size() (<span class="keyword">int64</span>, <span class="keyword">bool</span>)</span><br><span class="line">	Type() Type</span><br><span class="line">	Optimize() (Iterator, <span class="keyword">bool</span>)</span><br><span class="line">	SubIterators() []Iterator</span><br><span class="line">	Close() error</span><br><span class="line">	UID() <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面最重要的迭代器方法就是</p>
<ul>
<li>Result() Value</li>
<li>Next(ctx context.Context) bool</li>
</ul>
<p>Next方法被这个迭代器用来执行内嵌在它自己内部的另一个迭代器 Result这个函数用来获取执行结果</p>
<p>那么我们会很好奇迭代器这么抽象是怎样最终转化为mongodb的查询语句的呢？因为在cayley中使用的mongodb连接第三方包就是mgo.v2</p>
<p>其实我们知道迭代是一层一层嵌套的 那么我们可以看一下最底层的迭代器的结构 最底层的迭代器如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	uid        <span class="keyword">uint64</span></span><br><span class="line">	tags       graph.Tagger</span><br><span class="line">	qs         *QuadStore</span><br><span class="line">	collection <span class="keyword">string</span></span><br><span class="line">	limit      <span class="keyword">int64</span></span><br><span class="line">	constraint []FieldFilter</span><br><span class="line">	links      []Linkage <span class="comment">// used in Contains</span></span><br><span class="line"></span><br><span class="line">	iter   DocIterator</span><br><span class="line">	result graph.Value</span><br><span class="line">	size   <span class="keyword">int64</span></span><br><span class="line">	err    error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个迭代是位于cayley源代码中的nosql\iterator.go中声明的迭代器 其中我们可以看到它包含一个字段</p>
<pre><code>constraint []FieldFilter
</code></pre><p>FieldFilter在cayley定义如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FieldFilter represents a single field comparison operation.</span></span><br><span class="line"><span class="keyword">type</span> FieldFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">	Path   []<span class="keyword">string</span> <span class="comment">// path is a path to specific field in the document</span></span><br><span class="line">	Filter FilterOp <span class="comment">// comparison operation</span></span><br><span class="line">	Value  Value    <span class="comment">// value that will be compared with field of the document</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Filter FilterO是一个用来表示比较的字段 有</p>
<ul>
<li>Equal</li>
<li>NotEqual</li>
<li>GT</li>
<li>GTE</li>
<li>LT</li>
<li>LTE</li>
</ul>
<p>Value  Value就是存储的节点值</p>
<p>语义上 上面这个结构体可以根据比较大小的操作符FilterOp和它的值value 来转化为在mongodb中对图的具体某个节点的查询</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/20/cayley原理2/" data-id="cjqjgi45t000bqko02t8ikqgn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cayley/">cayley</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cayley原理一-获取查询结果" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/15/cayley原理一-获取查询结果/" class="article-date">
  <time datetime="2018-08-15T13:01:47.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/cayley原理一-获取查询结果/">cayley原理一(获取查询结果)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="查询结果的获取"><a href="#查询结果的获取" class="headerlink" title="查询结果的获取"></a>查询结果的获取</h2><p>首先我们假定cayley已将我们的查询语句path转化为mongodb的查询语句 现在我们分析cayley是如何从mongodb里面获取查询结果 并且返回给上层的</p>
<p>总体的结构如下(只包含从mongodb中获取查询结果 不包含解析为mongodb查询语句)<br><img src="http://static.zybuluo.com/gzm1997/ddaggos1xeyxb8nm3211m1d7/get.jpg" alt="get.jpg-67.1kB"></p>
<p>由cayley官方提供的hello world的查询方式如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := p.Iterate(<span class="literal">nil</span>).EachValue(<span class="literal">nil</span>, <span class="function"><span class="keyword">func</span><span class="params">(value quad.Value)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ignore</span></span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看见是调用了<strong>EachValue</strong>这个函数 这个函数是属于一个叫做<strong>IterateChain</strong>结构体的一个方法 如上提最左边的类 上图最左边是我们的顶层调用 越往右是底层调用</p>
<p>为了直观 我们从右边到左边 从底层到高层的调用如下</p>
<p> 1.mongo.go中的Iterator结构体(称为迭代器1)中调用Next()函数 这个Next()再调用mgo.v2\session.go中Iter结构体中的Next()函数 从而将从<strong>mgo</strong>中迭代的结果保存在迭代器1中的<strong>res字段</strong>中 这个字段类型是bson.M(实质上是一个map[string]interface{}类型) 然后迭代器1调用Doc()方法 将res类型转为Document(实质上为map[string]graph.Value)<br><img src="http://static.zybuluo.com/gzm1997/3cevje4c3hq094ifee3i02d7/image_1ckun71jb1l0s69khljmep15h2s.png" alt="image_1ckun71jb1l0s69khljmep15h2s.png-34.4kB"></p>
<p> 2.nosql\iterate.go中Iterator结构体(称为迭代器2)调用自己的Next()函数 进而调用步骤1中的迭代器1的Next()和Doc()函数完成步骤1的操作 并且转化为Document的结果存进迭代器2中的<strong>result字段</strong>中 类型是graph.Value<br><img src="http://static.zybuluo.com/gzm1997/o1y86b0ro82yi1clu3eotfrq/image_1ckun822b3bc14dec3k1u2pnvv39.png" alt="image_1ckun822b3bc14dec3k1u2pnvv39.png-60.3kB"></p>
<p> 3.iterate.go中的IterateChain结构体(称为迭代链)调用自己的Each()方法 进而 调用步骤2中的迭代器2中的Next()函数完成步骤2中的操作 并且使用迭代器2的Result()函数获取这个保存在迭代器2的Result字段中的结果<br><img src="http://static.zybuluo.com/gzm1997/zp9jikpfh9ok7gs7885n1p7i/image_1ckup1a0kv53hqeo1s1lb51c2ds.png" alt="image_1ckup1a0kv53hqeo1s1lb51c2ds.png-50.9kB"></p>
<hr>
<h2 id="使用接口实现多种实现方案"><a href="#使用接口实现多种实现方案" class="headerlink" title="使用接口实现多种实现方案"></a>使用接口实现多种实现方案</h2><p>上面图中的两部分绿色非常关键 两部分都是定义了很多方法的<strong>接口</strong> 我们称最右边的接口为接口1 另一个称为接口2</p>
<p>对于接口1来说<br>这些包含了若干方法的接口是声明在nosql.go中的DocIterator这个接口中的 并且被nosql\iterate.go中进行调用 在接口的具体实现上我们上面的方案是使用了mongo.go文件中的Iterator结构体实现方式 </p>
<p>试想一下：当我们实现另一个新的Iterator迭代器 并且都实现接口1的方法 但是在这些方法的定义上使用其他的nosql数据库进行底层存储 那么我就可以添加一种新的底层存储可选方案了</p>
<p>其实cayley可以使用mysql 还是mongodb bolt redis甚至内存等多种存储方式作为底层存储的原因就是：</p>
<blockquote>
<p>其实cayley在sql还是nosql类型方案的选择上就是通过<strong>接口2</strong>的实现方式不一样来实现的 而nosql方式的底层存储数据库到底选择何种nosql数据库也是通过<strong>接口1</strong>的实现方式不一样来实现的 sql具体数据库的选择也是类似</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/15/cayley原理一-获取查询结果/" data-id="cjqjgi45s0009qko06mvctzdh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cayley/">cayley</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM/">ORM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aiohttp/">aiohttp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/async/">async</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/backend/">backend</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/beego/">beego</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cayley/">cayley</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cookies/">cookies</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cors/">cors</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/">database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deep-web/">deep web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deploy/">deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dgraph/">dgraph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask/">flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask深入学习/">flask深入学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graph/">graph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gremlin/">gremlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hugegraph/">hugegraph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/image/">image</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mux/">mux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/package/">package</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rabbitMQ/">rabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/requests/">requests</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/servlet/">servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/session/">session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqlalchemy/">sqlalchemy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/subgraph/">subgraph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图数据库/">图数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图算法/">图算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图谱/">图谱</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件开发生命周期/">软件开发生命周期</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ORM/" style="font-size: 10px;">ORM</a> <a href="/tags/aiohttp/" style="font-size: 16px;">aiohttp</a> <a href="/tags/async/" style="font-size: 14px;">async</a> <a href="/tags/backend/" style="font-size: 10px;">backend</a> <a href="/tags/beego/" style="font-size: 12px;">beego</a> <a href="/tags/cayley/" style="font-size: 16px;">cayley</a> <a href="/tags/cookies/" style="font-size: 10px;">cookies</a> <a href="/tags/cors/" style="font-size: 10px;">cors</a> <a href="/tags/database/" style="font-size: 14px;">database</a> <a href="/tags/deep-web/" style="font-size: 10px;">deep web</a> <a href="/tags/deploy/" style="font-size: 10px;">deploy</a> <a href="/tags/dgraph/" style="font-size: 10px;">dgraph</a> <a href="/tags/docker/" style="font-size: 12px;">docker</a> <a href="/tags/flask/" style="font-size: 10px;">flask</a> <a href="/tags/flask深入学习/" style="font-size: 10px;">flask深入学习</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/go/" style="font-size: 20px;">go</a> <a href="/tags/graph/" style="font-size: 10px;">graph</a> <a href="/tags/gremlin/" style="font-size: 10px;">gremlin</a> <a href="/tags/hugegraph/" style="font-size: 10px;">hugegraph</a> <a href="/tags/image/" style="font-size: 10px;">image</a> <a href="/tags/java/" style="font-size: 18px;">java</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mux/" style="font-size: 10px;">mux</a> <a href="/tags/mysql/" style="font-size: 16px;">mysql</a> <a href="/tags/package/" style="font-size: 10px;">package</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/rabbitMQ/" style="font-size: 10px;">rabbitMQ</a> <a href="/tags/requests/" style="font-size: 10px;">requests</a> <a href="/tags/servlet/" style="font-size: 10px;">servlet</a> <a href="/tags/session/" style="font-size: 12px;">session</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/sqlalchemy/" style="font-size: 12px;">sqlalchemy</a> <a href="/tags/subgraph/" style="font-size: 10px;">subgraph</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/图数据库/" style="font-size: 12px;">图数据库</a> <a href="/tags/图算法/" style="font-size: 10px;">图算法</a> <a href="/tags/图谱/" style="font-size: 10px;">图谱</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/线程/" style="font-size: 10px;">线程</a> <a href="/tags/软件开发生命周期/" style="font-size: 10px;">软件开发生命周期</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/05/java基础2：树相关前哨/">java基础2：树相关前哨</a>
          </li>
        
          <li>
            <a href="/2018/12/24/ArrayList相关/">ArrayList相关</a>
          </li>
        
          <li>
            <a href="/2018/12/03/暑假学习总结/">暑假学习总结</a>
          </li>
        
          <li>
            <a href="/2018/12/03/subgraph概况/">subgraph概况</a>
          </li>
        
          <li>
            <a href="/2018/12/03/docker在测试中的作用/">docker在测试中的作用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 gzm1997<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>